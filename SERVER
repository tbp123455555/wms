const fetch = require('node-fetch');
const express = require('express');
const sqlite3 = require('sqlite3').verbose();
const multer = require('multer');
const path = require('path');
const fs = require('fs');
const DB_PATH = path.join(__dirname, 'warehouse.db');



const app = express();
const PORT = 3000;
const upload = multer({ dest: 'uploads/', storage: multer.memoryStorage() });

app.use(express.json());

// Single database instance
const db = new sqlite3.Database('./warehouse.db');

// Helper function for compatibility with the new endpoints
function getDB() {
    return db;
}
// ============================================
// SHIPSTATION API CONFIGURATION
// ============================================
const SHIPSTATION_API_KEY = '101f542259cf4a58b6dd85c879fe2e16';
const SHIPSTATION_API_SECRET = 'afddff346ac7436dbcabe7df512579a0';
const SHIPSTATION_BASE_URL = 'https://ssapi.shipstation.com';

// Helper function for ShipStation API calls
function shipstationRequest(endpoint, method = 'GET', body = null) {
    const auth = Buffer.from(`${SHIPSTATION_API_KEY}:${SHIPSTATION_API_SECRET}`).toString('base64');
    
    const options = {
        method: method,
        headers: {
            'Authorization': `Basic ${auth}`,
            'Content-Type': 'application/json'
        }
    };
    
    if (body && method !== 'GET') {
        options.body = JSON.stringify(body);
    }
    
    return fetch(`${SHIPSTATION_BASE_URL}${endpoint}`, options)
        .then(response => {
            if (!response.ok) {
                throw new Error(`ShipStation API error: ${response.status}`);
            }
            return response.json();
        });
}

// ============================================
// SHIPSTATION TEST ENDPOINT
// ============================================
app.get('/api/shipstation/test', async (req, res) => {
    try {
        // Test connection by fetching stores
        const stores = await shipstationRequest('/stores');
        
        res.json({
            success: true,
            message: 'ShipStation connection successful!',
            stores: stores.length,
            storeList: stores.map(s => ({ storeId: s.storeId, storeName: s.storeName }))
        });
    } catch (err) {
        console.error('ShipStation test failed:', err);
        res.status(500).json({
            success: false,
            error: err.message
        });
    }
});

// ============================================
// SYNC PRODUCTS FROM SHIPSTATION
// ============================================
app.post('/api/shipstation/sync-products', async (req, res) => {
    try {
        console.log('Starting ShipStation product sync...');
        
        let allProducts = [];
        let page = 1;
        let hasMore = true;
        
        // Fetch ALL ACTIVE products by paginating
        while (hasMore && page <= 20) { // Safety limit: 20 pages = 10,000 products
            console.log(`Fetching page ${page}...`);
            
            const response = await shipstationRequest(`/products?pageSize=500&page=${page}&showInactive=false`);
            const products = response.products || [];
            
            allProducts = allProducts.concat(products);
            
            hasMore = products.length === 500;
            page++;
            
            console.log(`Got ${products.length} products (total so far: ${allProducts.length})`);
        }
        
        console.log(`Found ${allProducts.length} total ACTIVE products in ShipStation`);
        
        let imported = 0;
        let updated = 0;
        let toAllocate = 0;
        let skipped = 0;
        let archived = 0;
        const errors = [];
        
        for (const product of allProducts) {
            const sku = product.sku;
            const name = product.name;
            const warehouseLocation = product.warehouseLocation || null;
            
            if (!sku) {
                skipped++;
                continue;
            }
            
           try {
    // Check if SKU is archived (check BOTH skus table AND archived_skus table)
    const isArchived = await new Promise((resolve, reject) => {
        db.get(`SELECT 
                    (SELECT COUNT(*) FROM skus WHERE sku_code = ? AND archived = 1) +
                    (SELECT COUNT(*) FROM archived_skus WHERE sku_code = ?) as archived_count`,
            [sku, sku], (err, row) => {
            if (err) reject(err);
            else resolve(row.archived_count > 0);
        });
    });
    
    if (isArchived) {
        // SKU is archived - skip it
        archived++;
        console.log('üóÑÔ∏è Skipping archived SKU:', sku);
        continue;
    }
    
    // Check if SKU already exists (for updating)
    const existing = await new Promise((resolve, reject) => {
        db.get('SELECT * FROM skus WHERE sku_code = ? LIMIT 1', [sku], (err, row) => {
            if (err) reject(err);
            else resolve(row);
        });
    });
                
                if (existing) {
                    // Update existing product name if changed
                    await new Promise((resolve, reject) => {
                        db.run('UPDATE skus SET product_name = ? WHERE sku_code = ?', 
                            [name, sku], function(err) {
                            if (err) reject(err);
                            else {
                                if (this.changes > 0) updated++;
                                resolve();
                            }
                        });
                    });
                } else if (warehouseLocation) {
                    // Import with location
                    let locationType = 'shelf';
                    if (warehouseLocation.match(/^[A-Z]{2}-\d{2}-\d$/)) {
                        locationType = 'pallet';
                    }
                    
                    await new Promise((resolve, reject) => {
                        db.run('INSERT INTO skus (sku_code, product_name, location, location_type, quantity, archived) VALUES (?, ?, ?, ?, ?, ?)',
                            [sku, name, warehouseLocation, locationType, null, 0], function(err) {
                            if (err) reject(err);
                            else {
                                imported++;
                                resolve();
                            }
                        });
                    });
                } else {
                    // NO LOCATION - Send to allocation queue
                    await new Promise((resolve, reject) => {
                        db.run('INSERT INTO skus (sku_code, product_name, location, location_type, quantity, archived) VALUES (?, ?, ?, ?, ?, ?)',
                            [sku, name, 'UNALLOCATED', 'pending', null, 0], function(err) {
                            if (err) reject(err);
                            else {
                                toAllocate++;
                                resolve();
                            }
                        });
                    });
                }
            } catch (err) {
                errors.push(`${sku}: ${err.message}`);
                skipped++;
            }
        }
        
        res.json({
            success: true,
            message: `Sync complete: ${imported} imported, ${updated} updated, ${toAllocate} awaiting allocation, ${archived} archived (ignored), ${skipped} skipped`,
            total: allProducts.length,
            imported,
            updated,
            toAllocate,
            archived,
            skipped,
            errors: errors.length > 0 ? errors : undefined
        });
        
    } catch (err) {
        console.error('ShipStation sync error:', err);
        res.status(500).json({
            success: false,
            error: err.message
        });
    }
});

// Add this endpoint temporarily - call it once to update your DB
app.get('/api/admin/add-archive-column', (req, res) => {
    db.run(`ALTER TABLE skus ADD COLUMN archived INTEGER DEFAULT 0`, (err) => {
        if (err) {
            // Column might already exist
            console.log('Archive column:', err.message);
            return res.json({ success: true, message: 'Column already exists or added' });
        }
        console.log('‚úÖ Added archive column to skus table');
        res.json({ success: true, message: 'Archive column added' });
    });
});

// ============================================
// UPDATE SHIPSTATION WITH OUR LOCATIONS
// ============================================
app.post('/api/shipstation/update-location', async (req, res) => {
    const { sku_code, location } = req.body;
    
    if (!sku_code || !location) {
        return res.status(400).json({ error: 'SKU code and location required' });
    }
    
    // Check if we have internet
    const hasInternet = await checkInternetConnection();
    
    if (!hasInternet) {
        // Queue for later
        queueShipStationUpdate('update_location', sku_code, location);
        
        return res.json({
            success: true,
            queued: true,
            message: `Queued: ${sku_code} ‚Üí ${location} (will sync when online)`
        });
    }
    
    try {
        // Try to update immediately
        const response = await shipstationRequest(`/products?sku=${encodeURIComponent(sku_code)}`);
        const products = response.products || [];
        
        if (products.length === 0) {
            // Product not found - queue it anyway
            queueShipStationUpdate('update_location', sku_code, location);
            
            return res.json({
                success: true,
                queued: true,
                message: `Product not found in ShipStation - queued for later sync`
            });
        }
        
        const product = products[0];
        
        await shipstationRequest('/products', 'PUT', {
            productId: product.productId,
            sku: product.sku,
            name: product.name,
            price: product.price,
            warehouseLocation: location
        });
        
        console.log(`‚úì Updated ${sku_code} location in ShipStation: ${location}`);
        
        res.json({
            success: true,
            message: `Updated ${sku_code} location to ${location} in ShipStation`
        });
        
    } catch (err) {
        console.error('ShipStation update error:', err);
        
        // If it failed, queue it
        queueShipStationUpdate('update_location', sku_code, location);
        
        res.json({
            success: true,
            queued: true,
            message: `Failed to update immediately - queued for retry`
        });
    }
});

// ============================================
// ARCHIVE SKU MANAGEMENT
// ============================================

// Permanently archive a SKU (add to archived_skus table)
app.post('/api/sku/archive-permanent', (req, res) => {
  const { sku_code } = req.body;
  
  if (!sku_code) {
    return res.status(400).json({ error: 'SKU code required' });
  }
  
  db.serialize(() => {
    // Get product name first
    db.get('SELECT product_name FROM skus WHERE sku_code = ? LIMIT 1', [sku_code], (err, product) => {
      const productName = product ? product.product_name : null;
      
      // Add to archived_skus table (permanent block list)
      db.run(`INSERT OR IGNORE INTO archived_skus (sku_code, product_name, reason) 
              VALUES (?, ?, ?)`,
        [sku_code, productName, 'Permanently archived'], (err) => {
        
        if (err) {
          console.error('Error adding to archived_skus:', err);
          return res.status(500).json({ error: err.message });
        }
        
        // Delete from skus table
        db.run('DELETE FROM skus WHERE sku_code = ?', [sku_code], function(err) {
          if (err) {
            console.error('Error deleting from skus:', err);
            return res.status(500).json({ error: err.message });
          }
          
          console.log('üóëÔ∏è Permanently archived SKU:', sku_code);
          
          res.json({
            success: true,
            message: `${sku_code} permanently archived and deleted`
          });
        });
      });
    });
  });
});


// One-time setup - creates archived_skus table if it doesn't exist
app.get('/api/admin/init-archive-system', (req, res) => {
  db.serialize(() => {
    // Create archived_skus table
    db.run(`CREATE TABLE IF NOT EXISTS archived_skus (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      sku_code TEXT UNIQUE NOT NULL,
      product_name TEXT,
      archived_at TEXT DEFAULT CURRENT_TIMESTAMP,
      reason TEXT
    )`, (err) => {
      if (err) {
        console.error('Error creating archived_skus:', err);
        return res.status(500).json({ error: err.message });
      }
      
      // Add archived column to skus if it doesn't exist
      db.run(`ALTER TABLE skus ADD COLUMN archived INTEGER DEFAULT 0`, (err) => {
        // Ignore error if column already exists
        console.log('Archive system initialized');
        
        res.json({
          success: true,
          message: 'Archive system initialized successfully'
        });
      });
    });
  });
});


// ============================================
// FIX DOUBLE QUOTES IN PRODUCT NAMES
// ============================================

// One-time fix endpoint - replaces " with inch
app.get('/api/admin/fix-quotes', (req, res) => {
    // First, get all products with quotes
    db.all(`SELECT id, product_name FROM skus WHERE product_name LIKE '%"%'`, (err, rows) => {
        if (err) {
            return res.status(500).json({ error: err.message });
        }
        
        if (rows.length === 0) {
            return res.json({ success: true, message: 'No products to fix', changes: 0 });
        }
        
        // Update each one
        let updated = 0;
        rows.forEach(row => {
            const newName = row.product_name.replace(/"/g, 'inch');
            db.run('UPDATE skus SET product_name = ? WHERE id = ?', [newName, row.id], (err) => {
                if (!err) updated++;
                
                // When all done
                if (updated === rows.length) {
                    res.json({ 
                        success: true, 
                        message: `Fixed ${updated} products`,
                        changes: updated 
                    });
                }
            });
        });
    });
});
app.get('/api/admin/setup-pallet-builder', (req, res) => {
    db.serialize(() => {
        // Table 1: Staging pallets
        db.run(`CREATE TABLE IF NOT EXISTS staging_pallets (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            pallet_code TEXT UNIQUE NOT NULL,
            created_at TEXT DEFAULT CURRENT_TIMESTAMP,
            status TEXT DEFAULT 'building'
        )`, (err) => {
            if (err) console.error('Error creating staging_pallets:', err);
            else console.log('‚úÖ Created staging_pallets table');
        });
        
        // Table 2: Items on staging pallets
        db.run(`CREATE TABLE IF NOT EXISTS staging_pallet_items (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            pallet_code TEXT NOT NULL,
            sku_code TEXT NOT NULL,
            product_name TEXT,
            quantity INTEGER NOT NULL,
            source_location TEXT,
            added_at TEXT DEFAULT CURRENT_TIMESTAMP,
            FOREIGN KEY (pallet_code) REFERENCES staging_pallets(pallet_code)
        )`, (err) => {
            if (err) console.error('Error creating staging_pallet_items:', err);
            else console.log('‚úÖ Created staging_pallet_items table');
        });
    });
    
    res.json({ 
        success: true, 
        message: 'Pallet Builder tables created successfully' 
    });
});

// Assign staging pallet to bay (alternative endpoint name)
app.post('/api/staging-pallets/:palletCode/assign-bay', (req, res) => {
    const palletCode = decodeURIComponent(req.params.palletCode);
    const { bay_location } = req.body;
    
    console.log('üìç Assigning pallet', palletCode, 'to bay', bay_location);
    
    if (!bay_location) {
        return res.status(400).json({ error: 'Bay location required' });
    }
    
    // Verify bay exists and is available
    db.get('SELECT * FROM pallet_bays WHERE location = ?', [bay_location], (err, bay) => {
        if (err) {
            return res.status(500).json({ error: err.message });
        }
        
        if (!bay) {
            return res.status(400).json({ error: `Bay ${bay_location} does not exist` });
        }
        
        // Check if bay already has stock
        db.get('SELECT COUNT(*) as count FROM skus WHERE location = ? AND location_type = ?',
            [bay_location, 'pallet'], (err, result) => {
            
            if (err) {
                return res.status(500).json({ error: err.message });
            }
            
            if (result.count > 0) {
                return res.status(400).json({ 
                    error: `Bay ${bay_location} already contains stock. Choose an empty bay.` 
                });
            }
            
            // Get all items from staging pallet
            db.all('SELECT * FROM staging_pallet_items WHERE pallet_code = ?', 
                [palletCode], (err, items) => {
                
                if (err) {
                    return res.status(500).json({ error: err.message });
                }
                
                if (items.length === 0) {
                    return res.status(400).json({ error: 'No items on pallet' });
                }
                
                console.log('üì¶ Moving', items.length, 'items to', bay_location);
                
                // Move all items to bay
                db.serialize(() => {
                    db.run('BEGIN TRANSACTION');
                    
                    let completed = 0;
                    let errors = [];
                    
                    items.forEach(item => {
                        // Check if SKU already exists in this bay
                        db.get('SELECT * FROM skus WHERE location = ? AND location_type = ? AND sku_code = ?',
                            [bay_location, 'pallet', item.sku_code], (err, existing) => {
                            
                            if (existing) {
                                // Merge quantities
                                const newQty = (existing.quantity || 0) + (item.quantity || 0);
                                
                                db.run('UPDATE skus SET quantity = ? WHERE location = ? AND location_type = ? AND sku_code = ?',
                                    [newQty, bay_location, 'pallet', item.sku_code], (err) => {
                                    
                                    if (err) {
                                        errors.push(item.sku_code + ': ' + err.message);
                                    } else {
                                        console.log('  ‚úì Merged', item.sku_code, '‚Üí', newQty, 'units');
                                    }
                                    checkComplete();
                                });
                            } else {
                                // Insert new
                                db.run(`INSERT INTO skus (location, location_type, sku_code, product_name, quantity)
                                        VALUES (?, 'pallet', ?, ?, ?)`,
                                    [bay_location, item.sku_code, item.product_name, item.quantity],
                                    (err) => {
                                        if (err) {
                                            errors.push(item.sku_code + ': ' + err.message);
                                        } else {
                                            console.log('  ‚úì Added', item.sku_code, '‚Üí', item.quantity, 'units');
                                        }
                                        checkComplete();
                                    }
                                );
                            }
                        });
                    });
                    
                    function checkComplete() {
                        completed++;
                        
                        if (completed === items.length) {
                            if (errors.length > 0) {
                                console.error('‚ùå Errors during assignment:', errors);
                                db.run('ROLLBACK');
                                return res.status(500).json({ 
                                    success: false, 
                                    errors: errors 
                                });
                            }
                            
                            // Delete staging pallet items
                            db.run('DELETE FROM staging_pallet_items WHERE pallet_code = ?', [palletCode], (err) => {
                                if (err) {
                                    console.error('Error deleting items:', err);
                                }
                                
                                // Update pallet status
                                db.run('UPDATE staging_pallets SET status = ?, assigned_at = datetime("now") WHERE pallet_code = ?', 
                                    ['assigned', palletCode], (err) => {
                                    
                                    // Update bay status
                                    db.run('UPDATE pallet_bays SET status = ? WHERE location = ?',
                                        ['occupied', bay_location], (err) => {
                                        
                                        db.run('COMMIT', (err) => {
                                            if (err) {
                                                console.error('‚ùå Commit error:', err);
                                                db.run('ROLLBACK');
                                                return res.status(500).json({ error: err.message });
                                            }
                                            
                                            console.log('‚úÖ Pallet assigned successfully:', palletCode, '‚Üí', bay_location);
                                            
                                            res.json({
                                                success: true,
                                                bay: bay_location,
                                                items_assigned: items.length
                                            });
                                        });
                                    });
                                });
                            });
                        }
                    }
                });
            });
        });
    });
});


app.get('/api/staging-pallets', (req, res) => {
    db.all(`SELECT sp.*, 
            COUNT(spi.id) as item_count,
            SUM(spi.quantity) as total_units
            FROM staging_pallets sp
            LEFT JOIN staging_pallet_items spi ON sp.pallet_code = spi.pallet_code
            WHERE sp.status = 'building'
            GROUP BY sp.id
            ORDER BY sp.created_at DESC`, 
        (err, pallets) => {
            if (err) {
                console.error('Error fetching staging pallets:', err);
                return res.status(500).json({ error: err.message });
            }
            res.json(pallets || []);
        }
    );
});



// ‚Üê PASTE THE NEW PRODUCT SEARCH ENDPOINT HERE

// Search products by SKU or name (for pallet builder)
app.get('/api/products/search', (req, res) => {
    const query = req.query.q;
    
    if (!query || query.length < 2) {
        return res.json([]);
    }
    
    const searchTerm = '%' + query + '%';
    
    // Search master products table, not current stock
    db.all(`SELECT DISTINCT sku_code, product_name
            FROM skus 
            WHERE (sku_code LIKE ? OR product_name LIKE ?)
            AND active = 1
            AND archived = 0 
            GROUP BY sku_code
            ORDER BY sku_code
            LIMIT 20`,
        [searchTerm, searchTerm],
        (err, results) => {
            if (err) {
                console.error('Product search error:', err);
                return res.status(500).json({ error: err.message });
            }
            
            res.json(results || []);
        }
    );
});

// Get staging pallets (next endpoint)
app.get('/api/staging-pallets', (req, res) => {
    // ... existing code ...
});

// Get pallet details with items
app.get('/api/staging-pallets/:palletCode', (req, res) => {
    const { palletCode } = req.params;
    
    db.get('SELECT * FROM staging_pallets WHERE pallet_code = ?', [palletCode], (err, pallet) => {
        if (err) {
            return res.status(500).json({ error: err.message });
        }
        if (!pallet) {
            return res.status(404).json({ error: 'Pallet not found' });
        }
        
        db.all('SELECT * FROM staging_pallet_items WHERE pallet_code = ? ORDER BY added_at', 
            [palletCode], (err, items) => {
                if (err) {
                    return res.status(500).json({ error: err.message });
                }
                
                res.json({
                    pallet: pallet,
                    items: items || []
                });
            }
        );
    });
});

// Create new staging pallet
app.post('/api/staging-pallets', (req, res) => {
    const { pallet_code } = req.body;
    
    if (!pallet_code) {
        return res.status(400).json({ error: 'Pallet code required' });
    }
    
    db.run('INSERT INTO staging_pallets (pallet_code) VALUES (?)', 
        [pallet_code], function(err) {
            if (err) {
                console.error('Error creating pallet:', err);
                return res.status(500).json({ error: err.message });
            }
            
            console.log('‚úÖ Created staging pallet:', pallet_code);
            
            res.json({ 
                success: true, 
                pallet_code: pallet_code,
                id: this.lastID
            });
        }
    );
});

// Add item to staging pallet (NEW stock, no source tracking)
app.post('/api/staging-pallets/:palletCode/items', (req, res) => {
    const palletCode = decodeURIComponent(req.params.palletCode);
    const { sku_code, product_name, quantity } = req.body;
    
    if (!sku_code || !quantity) {
        return res.status(400).json({ error: 'SKU code and quantity required' });
    }
    
    console.log('üì¶ Adding to pallet:', palletCode, '-', quantity + 'x', sku_code);
    
    // Verify pallet exists
    db.get('SELECT * FROM staging_pallets WHERE pallet_code = ?', [palletCode], (err, pallet) => {
        if (err) {
            console.error('Database error:', err);
            return res.status(500).json({ error: err.message });
        }
        
        if (!pallet) {
            return res.status(404).json({ error: 'Pallet not found' });
        }
        
        // Check if SKU already exists on this pallet
        db.get('SELECT * FROM staging_pallet_items WHERE pallet_code = ? AND sku_code = ?',
            [palletCode, sku_code], (err, existing) => {
            
            if (err) {
                console.error('Database error:', err);
                return res.status(500).json({ error: err.message });
            }
            
            if (existing) {
                // Update quantity
                const newQty = (existing.quantity || 0) + parseInt(quantity);
                
                db.run('UPDATE staging_pallet_items SET quantity = ? WHERE pallet_code = ? AND sku_code = ?',
                    [newQty, palletCode, sku_code], function(err) {
                    
                    if (err) {
                        console.error('Update error:', err);
                        return res.status(500).json({ error: err.message });
                    }
                    
                    console.log('‚úÖ Updated quantity:', sku_code, 'to', newQty);
                    
                    res.json({ 
                        success: true,
                        updated: true,
                        quantity: newQty
                    });
                });
            } else {
                // Insert new item - USE ONLY COLUMNS THAT EXIST
                db.run(`INSERT INTO staging_pallet_items 
                        (pallet_code, sku_code, product_name, quantity) 
                        VALUES (?, ?, ?, ?)`,
                    [palletCode, sku_code, product_name || '', parseInt(quantity)],
                    function(err) {
                        if (err) {
                            console.error('‚ùå Insert error:', err);
                            console.error('   Attempted values:', {
                                palletCode,
                                sku_code,
                                product_name: product_name || '',
                                quantity: parseInt(quantity)
                            });
                            return res.status(500).json({ 
                                error: err.message,
                                details: 'Failed to insert item into staging_pallet_items'
                            });
                        }
                        
                        console.log('‚úÖ Added new item:', sku_code);
                        
                        res.json({ 
                            success: true,
                            id: this.lastID
                        });
                    }
                );
            }
        });
    });
});

// Remove SKU from staging pallet
app.delete('/api/staging-pallets/:palletCode/items/:itemId', (req, res) => {
    const { palletCode, itemId } = req.params;
    
    db.run('DELETE FROM staging_pallet_items WHERE id = ? AND pallet_code = ?',
        [itemId, palletCode], function(err) {
            if (err) {
                console.error('Error removing item:', err);
                return res.status(500).json({ error: err.message });
            }
            
            console.log('‚úÖ Removed item', itemId, 'from pallet', palletCode);
            
            res.json({ success: true });
        }
    );
});

// Delete staging pallet
app.delete('/api/staging-pallets/:palletCode', (req, res) => {
    const { palletCode } = req.params;
    
    db.serialize(() => {
        db.run('DELETE FROM staging_pallet_items WHERE pallet_code = ?', [palletCode]);
        db.run('DELETE FROM staging_pallets WHERE pallet_code = ?', [palletCode], function(err) {
            if (err) {
                console.error('Error deleting pallet:', err);
                return res.status(500).json({ error: err.message });
            }
            
            console.log('‚úÖ Deleted staging pallet:', palletCode);
            
            res.json({ success: true });
        });
    });
});

// Smart bay suggestion algorithm based on SHELF locations (not pallet sources)
app.post('/api/staging-pallets/:palletCode/suggest-bay', (req, res) => {
    const { palletCode } = req.params;
    
    console.log('üéØ Calculating bay suggestions for', palletCode);
    
    // Get all items on this pallet
    db.all('SELECT * FROM staging_pallet_items WHERE pallet_code = ?', 
        [palletCode], (err, items) => {
            if (err) {
                return res.status(500).json({ error: err.message });
            }
            
            if (items.length === 0) {
                return res.json({ 
                    suggestions: [],
                    message: 'No items on pallet'
                });
            }
            
            console.log('üì¶ Pallet has', items.length, 'SKUs');
            
           // Look up SHELF locations for each SKU (try multiple formats)
            const skuList = items.map(i => i.sku_code);
            const placeholders = skuList.map(() => '?').join(',');
            
            db.all(`SELECT sku_code, location, location_type
                    FROM skus 
                    WHERE sku_code IN (${placeholders})
                    AND (
                        location_type = 'shelf'
                        OR location LIKE 'SHELF-%'
                        OR (location_type != 'pallet' AND location_type != 'hold' AND location NOT LIKE '__-__-%' AND location NOT LIKE 'HOLD-%')
                    )
                    GROUP BY sku_code
                    ORDER BY 
                        CASE 
                            WHEN location_type = 'shelf' THEN 1
                            WHEN location LIKE 'SHELF-%' THEN 2
                            ELSE 3
                        END`,
                skuList,
                (err, shelfLocations) => {
                    if (err) {
                        console.error('Error looking up shelf locations:', err);
                        return res.status(500).json({ error: err.message });
                    }
                    
                    console.log('üìç Raw shelf data:', shelfLocations);                    
                    if (shelfLocations.length === 0) {
                        // No shelf locations found - use fallback
                        console.log('‚ö†Ô∏è No shelf locations found - using general recommendations');
                        return findAvailableBays(null, null, res);
                    }
                    
                    // Build weighted location data based on quantities
                    const locationData = items.map(item => {
                        const shelfLoc = shelfLocations.find(s => s.sku_code === item.sku_code);
                        
                        if (!shelfLoc) {
                            return null;
                        }
                        
                        const aisle = extractAisle(shelfLoc.location);
                        const position = extractPosition(shelfLoc.location);
                        
                        return {
                            sku: item.sku_code,
                            shelf_location: shelfLoc.location,
                            quantity: item.quantity,
                            aisle: aisle,
                            position: position
                        };
                    }).filter(x => x !== null && x.aisle && x.position);
                    
                    if (locationData.length === 0) {
                        console.log('‚ö†Ô∏è Could not extract aisle/position data - using fallback');
                        return findAvailableBays(null, null, res);
                    }
                    
                    console.log('üìä Location data:', locationData.map(l => `${l.sku} @ ${l.shelf_location} (${l.quantity} units)`));
                    
                    // Calculate weighted position based on quantities
                    const totalUnits = locationData.reduce((sum, l) => sum + l.quantity, 0);
                    const weightedPosition = locationData.reduce((sum, l) => {
                        return sum + (l.position * l.quantity);
                    }, 0) / totalUnits;
                    
                    // Find dominant aisle (by quantity)
                    const aisleCount = {};
                    locationData.forEach(l => {
                        aisleCount[l.aisle] = (aisleCount[l.aisle] || 0) + l.quantity;
                    });
                    
                    const dominantAisle = Object.keys(aisleCount).reduce((a, b) => 
                        aisleCount[a] > aisleCount[b] ? a : b
                    );
                    
                    console.log('üéØ Weighted position:', Math.round(weightedPosition), 'in aisle', dominantAisle);
                    console.log('üìä Aisle distribution:', aisleCount);
                    
                    // Find empty bays in dominant aisle first
                    db.all(`SELECT pb.* 
                            FROM pallet_bays pb
                            WHERE pb.location LIKE ?
                            AND pb.status = 'available'
                            AND NOT EXISTS (
                                SELECT 1 FROM skus 
                                WHERE location = pb.location AND location_type = 'pallet'
                            )`,
                        [dominantAisle + '%'],
                        (err, emptyBays) => {
                            if (err) {
                                return res.status(500).json({ error: err.message });
                            }
                            
                            console.log('üîç Found', emptyBays.length, 'empty bays in', dominantAisle);
                            
                            if (emptyBays.length >= 3) {
                                // Found enough bays in optimal aisle
                                return scoreBaysAndRespond(emptyBays, weightedPosition, dominantAisle, locationData.length, res);
                            }
                            
                            console.log('‚ö†Ô∏è Only', emptyBays.length, 'bays in', dominantAisle, '- searching nearby aisles');
                            
                            // Not enough bays in dominant aisle, search nearby aisles
                            const aisleOrder = ['AA', 'BB', 'CC', 'DD', 'EE', 'FF', 'GG', 'HH'];
                            const dominantIndex = aisleOrder.indexOf(dominantAisle);
                            
                            if (dominantIndex === -1) {
                                console.error('‚ö†Ô∏è Invalid aisle:', dominantAisle);
                                return findAvailableBays(weightedPosition, dominantAisle, res);
                            }
                            
                            // Build list of nearby aisles (current +/- 1, then +/- 2, etc.)
                            const nearbyAisles = [dominantAisle];
                            for (let offset = 1; offset < aisleOrder.length; offset++) {
                                if (dominantIndex - offset >= 0) {
                                    nearbyAisles.push(aisleOrder[dominantIndex - offset]);
                                }
                                if (dominantIndex + offset < aisleOrder.length) {
                                    nearbyAisles.push(aisleOrder[dominantIndex + offset]);
                                }
                            }
                            
                            console.log('üîç Searching nearby aisles:', nearbyAisles.join(', '));
                            
                            // Search all nearby aisles
                            const aislePatterns = nearbyAisles.map(() => 'pb.location LIKE ?').join(' OR ');
                            const aisleValues = nearbyAisles.map(a => a + '%');
                            
                            db.all(`SELECT pb.* 
                                    FROM pallet_bays pb
                                    WHERE (${aislePatterns})
                                    AND pb.status = 'available'
                                    AND NOT EXISTS (
                                        SELECT 1 FROM skus 
                                        WHERE location = pb.location AND location_type = 'pallet'
                                    )
                                    ORDER BY pb.location
                                    LIMIT 15`,
                                aisleValues,
                                (err, allEmptyBays) => {
                                    if (err) {
                                        return res.status(500).json({ error: err.message });
                                    }
                                    
                                    console.log('üîç Found', allEmptyBays.length, 'total empty bays');
                                    
                                    if (allEmptyBays.length === 0) {
                                        return res.json({ 
                                            suggestions: [],
                                            message: 'No empty bays available in nearby aisles. Consider consolidating existing stock.'
                                        });
                                    }
                                    
                                    return scoreBaysAndRespond(allEmptyBays, weightedPosition, dominantAisle, locationData.length, res);
                                }
                            );
                        }
                    );
                }
            );
        }
    );
});
// Helper function to find any available bays when no source data
function findAvailableBays(weightedPos, dominantAisle, res) {
    db.all(`SELECT pb.* 
            FROM pallet_bays pb
            WHERE pb.status = 'available'
            AND NOT EXISTS (
                SELECT 1 FROM skus 
                WHERE location = pb.location AND location_type = 'pallet'
            )
            ORDER BY 
                CASE 
                    WHEN pb.aisle IN ('AA', 'BB') THEN 0
                    ELSE 1
                END,
                CASE
                    WHEN pb.level IN (2, 3) THEN 0
                    WHEN pb.level = 4 THEN 1
                    ELSE 2
                END,
                pb.location
            LIMIT 10`,
        (err, bays) => {
            if (err) {
                return res.status(500).json({ error: err.message });
            }
            
            if (bays.length === 0) {
                return res.json({ 
                    suggestions: [],
                    message: 'No empty bays available'
                });
            }
            
            /**
             * SCORING WHEN NO SOURCE DATA:
             * - Front aisles (AA, BB): +40 points
             * - Easy access levels (2-3): +30 points
             * - Lower bay numbers: +30 points
             * Max: 100 points
             */
            const scoredBays = bays.map(bay => {
                let score = 0;
                
                // Front aisle bonus
                if (bay.aisle === 'AA' || bay.aisle === 'BB') {
                    score += 40;
                }
                
                // Accessibility bonus
                if (bay.level === 2 || bay.level === 3) {
                    score += 30;
                } else if (bay.level === 4) {
                    score += 15;
                }
                
                // Prefer lower bay numbers (front of aisle)
                const bayNum = parseInt(bay.location.split('-')[1]);
                const positionScore = Math.max(0, 30 * (1 - (bayNum / 48)));
                score += positionScore;
                
                return {
                    location: bay.location,
                    aisle: bay.aisle,
                    level: bay.level,
                    distance: 'N/A',
                    score: Math.min(100, Math.round(score)),
                    isOptimalAisle: false
                };
            });
            
            const topSuggestions = scoredBays
                .sort((a, b) => b.score - a.score)
                .slice(0, 5);
            
            console.log('‚úÖ Suggestions (no source data):', topSuggestions.map(s => s.location + ' (' + s.score + ')'));
            
            res.json({
                suggestions: topSuggestions,
                dominantAisle: 'N/A',
                sourceCount: 0,
                message: 'No shelf locations found - showing general recommendations'
            });
        }
    );
}
// Helper function to score bays and send response
function scoreBaysAndRespond(bays, weightedPosition, dominantAisle, sourceCount, res) {
    const scoredBays = bays.map(bay => {
        const bayPosition = parseInt(bay.location.split('-')[1]);
        const distance = Math.abs(bayPosition - weightedPosition);
        
        /**
         * SCORING SYSTEM (max 100 points):
         * 
         * 1. PROXIMITY SCORE (0-60 points):
         *    - Distance from weighted center position
         *    - Closer = higher score
         *    - Max 60 points at distance 0, decreases as distance increases
         * 
         * 2. AISLE MATCH (0-30 points):
         *    - Optimal aisle (matches shelf locations): +30 points
         *    - Adjacent aisle: +15 points
         *    - Other aisles: 0 points
         * 
         * 3. ACCESSIBILITY (0-10 points):
         *    - Level 2-3 (easy reach): +10 points
         *    - Level 4 (high): +5 points
         *    - Level 5 (very high): 0 points
         * 
         * TOTAL: Max 100 points
         */
        
        // 1. PROXIMITY SCORE (0-60 points)
        // Use exponential decay: closer positions get much higher scores
        const maxDistance = 48; // Maximum bay number
        const proximityScore = Math.max(0, 60 * (1 - (distance / maxDistance)));
        
        // 2. AISLE MATCH SCORE (0-30 points)
        let aisleScore = 0;
        if (bay.aisle === dominantAisle) {
            // Perfect match - optimal aisle
            aisleScore = 30;
        } else {
            // Check if it's an adjacent aisle
            const aisleOrder = ['AA', 'BB', 'CC', 'DD', 'EE', 'FF', 'GG', 'HH'];
            const dominantIndex = aisleOrder.indexOf(dominantAisle);
            const bayIndex = aisleOrder.indexOf(bay.aisle);
            
            if (dominantIndex >= 0 && bayIndex >= 0) {
                const aisleDifference = Math.abs(dominantIndex - bayIndex);
                if (aisleDifference === 1) {
                    // Adjacent aisle - partial credit
                    aisleScore = 15;
                } else if (aisleDifference === 2) {
                    // Two aisles away - small credit
                    aisleScore = 5;
                }
                // 3+ aisles away = 0 points
            }
        }
        
        // 3. ACCESSIBILITY SCORE (0-10 points)
        let accessibilityScore = 0;
        if (bay.level === 2 || bay.level === 3) {
            // Ideal picking height
            accessibilityScore = 10;
        } else if (bay.level === 4) {
            // High but reachable
            accessibilityScore = 5;
        }
        // Level 5 = 0 points (too high)
        
        // TOTAL SCORE (capped at 100)
        const totalScore = Math.min(100, Math.round(proximityScore + aisleScore + accessibilityScore));
        
        return {
            location: bay.location,
            aisle: bay.aisle,
            level: bay.level,
            distance: distance,
            score: totalScore,
            isOptimalAisle: bay.aisle === dominantAisle,
            // Debug info (can remove in production)
            scoreBreakdown: {
                proximity: Math.round(proximityScore),
                aisle: aisleScore,
                accessibility: accessibilityScore
            }
        };
    });
    
    // Sort by score (highest first) and return top suggestions
    const topSuggestions = scoredBays
        .sort((a, b) => {
            // Primary sort: by score
            if (b.score !== a.score) return b.score - a.score;
            
            // Tiebreaker 1: prefer optimal aisle
            if (b.isOptimalAisle !== a.isOptimalAisle) {
                return b.isOptimalAisle ? 1 : -1;
            }
            
            // Tiebreaker 2: prefer closer distance
            return a.distance - b.distance;
        })
        .slice(0, 5); // Return top 5
    
    console.log('‚úÖ Top suggestions:');
    topSuggestions.forEach((s, idx) => {
        console.log(`   ${idx + 1}. ${s.location} - Score: ${s.score}/100 (Proximity: ${s.scoreBreakdown.proximity}, Aisle: ${s.scoreBreakdown.aisle}, Access: ${s.scoreBreakdown.accessibility})`);
    });
    
    res.json({
        suggestions: topSuggestions,
        weightedCenter: Math.round(weightedPosition * 10) / 10, // Round to 1 decimal
        dominantAisle: dominantAisle,
        sourceCount: sourceCount
    });
}
// Helper functions for bay suggestion
function extractAisle(location) {
    if (!location) return null;
    // Handle pallet bays (AA-12-2) and shelves (SHELF-A12)
    if (location.match(/^[A-Z]{2}-/)) {
        return location.split('-')[0];
    }
    if (location.match(/SHELF-([A-Z])/)) {
        return location.match(/SHELF-([A-Z])/)[1];
    }
    return null;
}

function extractPosition(location) {
    if (!location) return null;
    // Handle pallet bays (AA-12-2)
    if (location.match(/^[A-Z]{2}-(\d+)-/)) {
        return parseInt(location.match(/^[A-Z]{2}-(\d+)-/)[1]);
    }
    // Handle shelves (SHELF-A12)
    if (location.match(/SHELF-[A-Z](\d+)/)) {
        return parseInt(location.match(/SHELF-[A-Z](\d+)/)[1]);
    }
    return null;
}

// ============================================
// ARCHIVE SKU MANAGEMENT
// ============================================

// Archive a SKU (mark as archived, block from future imports)
app.post('/api/sku/archive', (req, res) => {
  const { sku_code } = req.body;
  
  if (!sku_code) {
    return res.status(400).json({ error: 'SKU code required' });
  }
  
  console.log('üì¶ Archiving SKU:', sku_code);
  
  db.run('UPDATE skus SET archived = 1 WHERE sku_code = ?', [sku_code], function(err) {
    if (err) {
      console.error('Archive error:', err);
      return res.status(500).json({ error: err.message });
    }
    
    if (this.changes === 0) {
      console.log('‚ö†Ô∏è SKU not found:', sku_code);
      return res.status(404).json({ error: 'SKU not found' });
    }
    
    console.log('‚úÖ Archived SKU:', sku_code, '- Rows updated:', this.changes);
    
    res.json({
      success: true,
      message: `${sku_code} archived - will not sync from ShipStation anymore`
    });
  });
});
// Unarchive a SKU
app.post('/api/sku/unarchive', (req, res) => {
    const { sku_code } = req.body;
    
    if (!sku_code) {
        return res.status(400).json({ error: 'SKU code required' });
    }
    
    db.run('UPDATE skus SET archived = 0 WHERE sku_code = ?', [sku_code], function(err) {
        if (err) {
            console.error('Unarchive error:', err);
            return res.status(500).json({ error: err.message });
        }
        
        if (this.changes === 0) {
            return res.status(404).json({ error: 'SKU not found' });
        }
        
        console.log('‚úì Unarchived SKU:', sku_code);
        
        res.json({ 
            success: true, 
            message: `${sku_code} unarchived - will sync from ShipStation again` 
        });
    });
});

// Search for available bays (for autocomplete)
app.get('/api/bays/search-available', (req, res) => {
    const query = req.query.q;
    
    if (!query || query.length < 1) {
        return res.json([]);
    }
    
    const searchTerm = '%' + query + '%';
    
    db.all(`SELECT pb.location, pb.aisle, pb.level
            FROM pallet_bays pb
            WHERE pb.location LIKE ?
            AND pb.status = 'available'
            AND NOT EXISTS (
                SELECT 1 FROM skus 
                WHERE location = pb.location AND location_type = 'pallet'
            )
            ORDER BY pb.location
            LIMIT 20`,
        [searchTerm],
        (err, bays) => {
            if (err) {
                console.error('Bay search error:', err);
                return res.status(500).json({ error: err.message });
            }
            
            res.json(bays || []);
        }
    );
});
// Get a product's current location (for pallet builder bay suggestions)
app.get('/api/products/location/:sku', (req, res) => {
    const skuCode = req.params.sku;
    
    // Find the most common location for this SKU
    db.get(`SELECT location, location_type, COUNT(*) as count
        FROM skus 
        WHERE sku_code = ? 
        AND location != 'UNALLOCATED'
        AND active = 1
        GROUP BY location
        ORDER BY count DESC
        LIMIT 1`,
        [skuCode],
        (err, result) => {
            if (err) {
                console.error('Error finding product location:', err);
                return res.status(500).json({ error: err.message });
            }
            
            if (!result) {
                console.log('üìç No location found for', skuCode);
                return res.json({ location: null });
            }
            
            console.log('üìç Found', skuCode, 'at', result.location);
            
            res.json({
                location: result.location,
                location_type: result.location_type
            });
        }
    );
});

// Assign staging pallet to actual bay
app.post('/api/staging-pallets/:palletCode/assign', (req, res) => {
    const { palletCode } = req.params;
    const { bay_location } = req.body;
    
    if (!bay_location) {
        return res.status(400).json({ error: 'Bay location required' });
    }
    
    // Get all items from staging pallet
    db.all('SELECT * FROM staging_pallet_items WHERE pallet_code = ?', 
        [palletCode], (err, items) => {
            if (err) {
                return res.status(500).json({ error: err.message });
            }
            
            if (items.length === 0) {
                return res.status(400).json({ error: 'No items on pallet' });
            }
            
            // Move all items to actual bay
            db.serialize(() => {
                db.run('BEGIN TRANSACTION');
                
                let completed = 0;
                let errors = [];
                
                items.forEach(item => {
                    db.run(`INSERT INTO skus (location, location_type, sku_code, product_name, quantity)
                            VALUES (?, 'pallet', ?, ?, ?)`,
                        [bay_location, item.sku_code, item.product_name, item.quantity],
                        (err) => {
                            if (err) {
                                console.error('Error assigning item:', err);
                                errors.push(item.sku_code + ': ' + err.message);
                            }
                            
                            completed++;
                            
                            if (completed === items.length) {
                                if (errors.length > 0) {
                                    db.run('ROLLBACK');
                                    return res.status(500).json({ 
                                        success: false, 
                                        errors: errors 
                                    });
                                }
                                
                                // Delete staging pallet
                                db.run('DELETE FROM staging_pallet_items WHERE pallet_code = ?', [palletCode]);
                                db.run('UPDATE staging_pallets SET status = ? WHERE pallet_code = ?', 
                                    ['assigned', palletCode]);
                                
                                db.run('COMMIT', (err) => {
                                    if (err) {
                                        console.error('Commit error:', err);
                                        return res.status(500).json({ error: err.message });
                                    }
                                    
                                    console.log('‚úÖ Assigned pallet', palletCode, 'to bay', bay_location);
                                    
                                    res.json({
                                        success: true,
                                        bay: bay_location,
                                        items_assigned: items.length
                                    });
                                });
                            }
                        }
                    );
                });
            });
        }
    );
});

// Setup archived SKUs table
app.get('/api/admin/setup-archive-table', (req, res) => {
    db.run(`CREATE TABLE IF NOT EXISTS archived_skus (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        sku_code TEXT UNIQUE NOT NULL,
        product_name TEXT,
        archived_at TEXT DEFAULT CURRENT_TIMESTAMP,
        reason TEXT
    )`, (err) => {
        if (err) {
            console.error('Error creating archived_skus table:', err);
            return res.status(500).json({ error: err.message });
        }
        
        console.log('‚úÖ Archived SKUs table ready');
        
        res.json({ 
            success: true, 
            message: 'Archived SKUs table created successfully' 
        });
    });
});

// Get all archived SKUs
app.get('/api/sku/archived', (req, res) => {
    db.all(`SELECT sku_code, product_name, location, location_type, created_at 
            FROM skus 
            WHERE archived = 1 
            ORDER BY sku_code`, (err, rows) => {
        if (err) {
            console.error('Get archived error:', err);
            return res.status(500).json({ error: err.message });
        }
        res.json(rows || []);
    });
});

// Bulk archive by location (archive all SKUs in a bay)
app.post('/api/sku/archive-location', (req, res) => {
    const { location } = req.body;
    
    if (!location) {
        return res.status(400).json({ error: 'Location required' });
    }
    
    db.run('UPDATE skus SET archived = 1 WHERE location = ?', [location], function(err) {
        if (err) {
            console.error('Bulk archive error:', err);
            return res.status(500).json({ error: err.message });
        }
        
        console.log('‚úì Archived', this.changes, 'SKUs at location:', location);
        
        res.json({ 
            success: true, 
            archived: this.changes,
            message: `Archived ${this.changes} SKUs at ${location}` 
        });
    });
});

// ============================================
// GET PRODUCT INFO FROM SHIPSTATION
// ============================================
app.get('/api/shipstation/product/:sku', async (req, res) => {
    const { sku } = req.params;
    
    try {
        const response = await shipstationRequest(`/products?sku=${encodeURIComponent(sku)}`);
        const products = response.products || [];
        
        if (products.length === 0) {
            return res.status(404).json({ 
                success: false,
                error: 'Product not found' 
            });
        }
        
        res.json({
            success: true,
            product: products[0]
        });
        
    } catch (err) {
        console.error('ShipStation product lookup error:', err);
        res.status(500).json({
            success: false,
            error: err.message
        });
    }
});
// Permanently delete a deactivated SKU
app.post('/api/admin/delete-sku', (req, res) => {
    const { sku_code } = req.body;
    
    if (!sku_code) {
        return res.status(400).json({ error: 'SKU code required' });
    }
    
    // Safety check: Only allow deletion of deactivated SKUs
    db.get('SELECT COUNT(*) as count FROM skus WHERE sku_code = ? AND active = 1',
        [sku_code],
        (err, result) => {
            if (err) {
                return res.status(500).json({ error: err.message });
            }
            
            if (result.count > 0) {
                return res.status(400).json({ 
                    error: 'Cannot delete active SKU. Please deactivate it first.' 
                });
            }
            
            // Safe to delete - it's already deactivated
            db.run('DELETE FROM skus WHERE sku_code = ?',
                [sku_code],
                function(err) {
                    if (err) {
                        console.error('Error deleting SKU:', err);
                        return res.status(500).json({ error: err.message });
                    }
                    
                    console.log('üóëÔ∏è Permanently deleted SKU:', sku_code, '- Removed', this.changes, 'records');
                    
                    res.json({ 
                        success: true,
                        sku_code: sku_code,
                        records_deleted: this.changes
                    });
                }
            );
        }
    );
});

db.serialize(() => {
    db.run(`CREATE TABLE IF NOT EXISTS pallet_bays (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        location TEXT UNIQUE NOT NULL,
        aisle TEXT NOT NULL,
        bay_number INTEGER NOT NULL,
        level INTEGER NOT NULL,
        status TEXT DEFAULT 'available',
        notes TEXT,
        created_at DATETIME DEFAULT CURRENT_TIMESTAMP
    )`);

    db.run(`CREATE TABLE IF NOT EXISTS skus (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        location TEXT NOT NULL,
        location_type TEXT NOT NULL,
        sku_code TEXT NOT NULL,
        product_name TEXT,
        quantity INTEGER,
        created_at DATETIME DEFAULT CURRENT_TIMESTAMP
    )`);

    db.run(`CREATE TABLE IF NOT EXISTS bundles (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        bundle_code TEXT UNIQUE NOT NULL,
        bundle_name TEXT,
        created_at DATETIME DEFAULT CURRENT_TIMESTAMP
    )`);

    db.run(`CREATE TABLE IF NOT EXISTS bundle_components (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        bundle_code TEXT NOT NULL,
        component_sku TEXT NOT NULL,
        quantity_needed INTEGER NOT NULL,
        FOREIGN KEY (bundle_code) REFERENCES bundles(bundle_code)
    )`);

    db.run(`CREATE TABLE IF NOT EXISTS hold_locations (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        location TEXT UNIQUE NOT NULL,
        original_bay TEXT,
        reason TEXT,
        status TEXT DEFAULT 'active',
        created_at DATETIME DEFAULT CURRENT_TIMESTAMP
    )`);

    db.run(`CREATE TABLE IF NOT EXISTS movement_history (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        from_location TEXT,
        to_location TEXT,
        sku_code TEXT,
        reason TEXT,
        moved_at DATETIME DEFAULT CURRENT_TIMESTAMP
    )`);

    db.get("SELECT COUNT(*) as count FROM pallet_bays", (err, row) => {
        if (row.count === 0) {
            const aisles = ['AA', 'BB', 'CC', 'DD', 'EE'];
            const stmt = db.prepare("INSERT INTO pallet_bays (location, aisle, bay_number, level, status) VALUES (?, ?, ?, ?, 'available')");
            aisles.forEach(aisle => {
                for (let bay = 1; bay <= 48; bay++) {
                    [2, 3, 4].forEach(level => {
                        const location = `${aisle}-${String(bay).padStart(2, '0')}-${level}`;
                        stmt.run(location, aisle, bay, level);
                    });
                }
            });
            stmt.finalize();
            console.log('Created 882 pallet bays');
        }
    });
});
db.run(`CREATE TABLE IF NOT EXISTS shipstation_queue (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    action TEXT NOT NULL,
    sku_code TEXT NOT NULL,
    location TEXT,
    quantity INTEGER,
    payload TEXT,
    created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
    retry_count INTEGER DEFAULT 0,
    status TEXT DEFAULT 'pending'
)`);

// Helper to check internet connection
async function checkInternetConnection() {
    try {
        const response = await fetch('https://www.google.com', { 
            method: 'HEAD',
            timeout: 5000 
        });
        return response.ok;
    } catch (err) {
        return false;
    }
}

// Add to queue instead of failing
function queueShipStationUpdate(action, sku_code, location, quantity = null) {
    const payload = JSON.stringify({ sku_code, location, quantity });
    
    db.run(`INSERT INTO shipstation_queue (action, sku_code, location, quantity, payload) 
            VALUES (?, ?, ?, ?, ?)`,
        [action, sku_code, location, quantity, payload], function(err) {
        if (err) {
            console.error('‚ùå Failed to queue update:', err);
        } else {
            console.log('üìã Queued ShipStation update:', action, sku_code, '‚Üí', location);
        }
    });
}

// Process queued updates
async function processShipStationQueue() {
    // Check if we have internet
    const hasInternet = await checkInternetConnection();
    
    if (!hasInternet) {
        console.log('‚ö†Ô∏è No internet connection - queue will be processed when connection returns');
        return { success: false, reason: 'offline' };
    }
    
    return new Promise((resolve) => {
        db.all(`SELECT * FROM shipstation_queue WHERE status = 'pending' ORDER BY created_at ASC LIMIT 50`,
            async (err, items) => {
            
            if (err || !items || items.length === 0) {
                return resolve({ success: true, processed: 0 });
            }
            
            let processed = 0;
            let failed = 0;
            
            for (const item of items) {
                try {
                    const payload = JSON.parse(item.payload);
                    
                    if (item.action === 'update_location') {
                        // Try to update ShipStation
                        const response = await shipstationRequest(`/products?sku=${encodeURIComponent(item.sku_code)}`);
                        const products = response.products || [];
                        
                        if (products.length > 0) {
                            const product = products[0];
                            await shipstationRequest('/products', 'PUT', {
                                productId: product.productId,
                                sku: product.sku,
                                name: product.name,
                                price: product.price,
                                warehouseLocation: item.location
                            });
                            
                            // Mark as completed
                            db.run('UPDATE shipstation_queue SET status = ? WHERE id = ?', ['completed', item.id]);
                            processed++;
                            console.log('‚úÖ Synced queued update:', item.sku_code, '‚Üí', item.location);
                        } else {
                            // Product not found - mark as failed
                            db.run('UPDATE shipstation_queue SET status = ?, retry_count = retry_count + 1 WHERE id = ?', 
                                ['failed', item.id]);
                            failed++;
                        }
                    }
                } catch (err) {
                    console.error('‚ùå Failed to process queue item:', item.id, err.message);
                    
                    // Increment retry count
                    db.run('UPDATE shipstation_queue SET retry_count = retry_count + 1 WHERE id = ?', [item.id]);
                    
                    // If retried too many times, mark as failed
                    if (item.retry_count >= 5) {
                        db.run('UPDATE shipstation_queue SET status = ? WHERE id = ?', ['failed', item.id]);
                    }
                    
                    failed++;
                }
            }
            
            resolve({ success: true, processed, failed, total: items.length });
        });
    });
}

// ============================================
// QUEUE MANAGEMENT ENDPOINTS
// ============================================

app.get('/api/shipstation/queue/status', (req, res) => {
    db.all(`SELECT 
            COUNT(*) as total,
            SUM(CASE WHEN status = 'pending' THEN 1 ELSE 0 END) as pending,
            SUM(CASE WHEN status = 'completed' THEN 1 ELSE 0 END) as completed,
            SUM(CASE WHEN status = 'failed' THEN 1 ELSE 0 END) as failed
            FROM shipstation_queue`, (err, result) => {
        if (err) return res.status(500).json({ error: err.message });
        
        checkInternetConnection().then(hasInternet => {
            res.json({
                online: hasInternet,
                queue: result[0]
            });
        });
    });
});

app.post('/api/shipstation/queue/process', async (req, res) => {
    try {
        const result = await processShipStationQueue();
        res.json(result);
    } catch (err) {
        res.status(500).json({ success: false, error: err.message });
    }
});

app.get('/api/shipstation/queue/list', (req, res) => {
    db.all(`SELECT * FROM shipstation_queue WHERE status = 'pending' ORDER BY created_at DESC LIMIT 100`,
        (err, rows) => {
        if (err) return res.status(500).json({ error: err.message });
        res.json(rows || []);
    });
});

// Auto-process queue every 5 minutes
setInterval(async () => {
    const result = await processShipStationQueue();
    if (result.processed > 0) {
        console.log('üîÑ Auto-processed ShipStation queue:', result.processed, 'items');
    }
}, 5 * 60 * 1000); // 5 minutes

// ============================================
// DASHBOARD STATS (for top banner)
// ============================================
app.get('/api/stats', (req, res) => {
  const stats = {};
  
  // Get total physical pallet bays
  db.get('SELECT COUNT(*) as total_bays FROM pallet_bays', (err, row) => {
    if (err) {
      console.error('Stats error:', err);
      return res.status(500).json({ error: err.message });
    }
    
    stats.total_bays = row.total_bays;
    
    // Get occupied bays (bays with actual stock)
    db.get(`SELECT COUNT(DISTINCT pb.location) as occupied_bays 
            FROM pallet_bays pb
            INNER JOIN skus s ON s.location = pb.location AND s.location_type = 'pallet'`,
      (err, occupiedRow) => {
        if (err) {
          console.error('Occupied bays error:', err);
          return res.status(500).json({ error: err.message });
        }
        
        stats.occupied_bays = occupiedRow ? occupiedRow.occupied_bays : 0;
        
        // Calculate empty bays
        stats.empty_bays = stats.total_bays - stats.occupied_bays;
        
        // Calculate utilization percentage (CAPPED AT 100%)
        stats.utilization_percent = stats.total_bays > 0 
          ? Math.min(100, Math.round((stats.occupied_bays / stats.total_bays) * 100))
          : 0;
        
        // Get total shelves
        db.get('SELECT COUNT(DISTINCT location) as total_shelves FROM skus WHERE location_type = "shelf"', 
          (err, shelfRow) => {
            if (err) console.error('Shelves error:', err);
            stats.total_shelves = shelfRow ? shelfRow.total_shelves : 0;
            
            // Get total unique SKUs
            db.get('SELECT COUNT(DISTINCT sku_code) as total_skus FROM skus WHERE (archived IS NULL OR archived = 0)', 
              (err, skuRow) => {
                if (err) console.error('SKUs error:', err);
                stats.total_skus = skuRow ? skuRow.total_skus : 0;
                
                // Get pallets on hold
                db.get('SELECT COUNT(*) as active_holds FROM pallet_bays WHERE status = "on_hold"', 
                  (err, holdRow) => {
                    if (err) console.error('Holds error:', err);
                    stats.active_holds = holdRow ? holdRow.active_holds : 0;
                    
                    console.log('üìä Dashboard stats:', stats);
                    res.json(stats);
                  }
                );
              }
            );
          }
        );
      }
    );
  });
});


// Analytics stats (used by Analytics dashboard)
app.get('/api/analytics/stats', (req, res) => {
  const stats = {};
  
  // Get warehouse utilization
  db.get('SELECT COUNT(*) as total_bays FROM pallet_bays', (err, row) => {
    if (err) {
      return res.status(500).json({ error: err.message });
    }
    
    const totalBays = row.total_bays;
    
    // Get occupied bays
    db.get(`SELECT COUNT(DISTINCT pb.location) as occupied_bays 
            FROM pallet_bays pb
            INNER JOIN skus s ON s.location = pb.location AND s.location_type = 'pallet'`,
      (err, occupiedRow) => {
        if (err) {
          return res.status(500).json({ error: err.message });
        }
        
        const occupiedBays = occupiedRow ? occupiedRow.occupied_bays : 0;
        
        // Calculate utilization (CAPPED AT 100%)
        stats.utilizationRate = totalBays > 0 
          ? Math.min(100, Math.round((occupiedBays / totalBays) * 100))
          : 0;
        
        // Get total movements in last 30 days
        db.get(`SELECT COUNT(*) as movements 
                FROM movement_history 
                WHERE moved_at >= datetime('now', '-30 days')`,
          (err, movRow) => {
            if (err) {
              console.error('Movements error:', err);
              stats.totalMovements = 0;
            } else {
              stats.totalMovements = movRow ? movRow.movements : 0;
            }
            
            // Get unique active SKUs
            db.get(`SELECT COUNT(DISTINCT sku_code) as unique_skus 
                    FROM skus 
                    WHERE (archived IS NULL OR archived = 0)`,
              (err, skuRow) => {
                if (err) {
                  console.error('SKUs error:', err);
                  stats.uniqueSKUs = 0;
                } else {
                  stats.uniqueSKUs = skuRow ? skuRow.unique_skus : 0;
                }
                
                // Get slow movers (pallets not moved in 30+ days) - FIXED QUERY
                db.get(`SELECT COUNT(*) as slow_count FROM (
                          SELECT pb.location
                          FROM pallet_bays pb
                          LEFT JOIN movement_history mh ON (mh.from_location = pb.location OR mh.to_location = pb.location)
                          WHERE EXISTS (SELECT 1 FROM skus WHERE location = pb.location AND location_type = 'pallet')
                          GROUP BY pb.location
                          HAVING MAX(mh.moved_at) < datetime('now', '-30 days') OR MAX(mh.moved_at) IS NULL
                        )`,
                  (err, slowRow) => {
                    if (err) {
                      console.error('Slow movers count error:', err);
                      stats.slowMovers = 0;
                    } else {
                      stats.slowMovers = slowRow ? slowRow.slow_count : 0;
                    }
                    
                    console.log('üìä Analytics stats:', stats);
                    res.json(stats);
                  }
                );
              }
            );
          }
        );
      }
    );
  });
});


// Aisle activity - movements in last 30 days
app.get('/api/analytics/aisle-activity', (req, res) => {
  db.all(`
    SELECT 
      SUBSTR(from_location, 1, 2) as aisle,
      COUNT(*) as movements
    FROM movement_history
    WHERE moved_at >= datetime('now', '-30 days')
      AND from_location LIKE '__-__-%'
    GROUP BY aisle
    ORDER BY movements DESC
  `, (err, rows) => {
    if (err) {
      console.error('Aisle activity error:', err);
      return res.status(500).json({ error: err.message });
    }
    
    // If no data, show all aisles with 0
    if (!rows || rows.length === 0) {
      const aisles = ['AA', 'BB', 'CC', 'DD', 'EE', 'FF'];
      rows = aisles.map(a => ({ aisle: a, movements: 0 }));
    }
    
    console.log('üìä Aisle activity:', rows);
    res.json(rows);
  });
});

// Slow movers - PALLETS not moved in 30+ days (CLEAN DISPLAY)
app.get('/api/analytics/slow-movers', (req, res) => {
  db.all(`
    SELECT 
      pb.location,
      COUNT(DISTINCT s.sku_code) as sku_count,
      MAX(mh.moved_at) as last_moved,
      CASE 
        WHEN MAX(mh.moved_at) IS NULL THEN 999
        ELSE CAST(julianday('now') - julianday(MAX(mh.moved_at)) AS INTEGER)
      END as days_idle
    FROM pallet_bays pb
    INNER JOIN skus s ON s.location = pb.location AND s.location_type = 'pallet'
    LEFT JOIN movement_history mh ON (mh.from_location = pb.location OR mh.to_location = pb.location)
    GROUP BY pb.location
    HAVING days_idle >= 30
    ORDER BY days_idle DESC
    LIMIT 50
  `, (err, rows) => {
    if (err) {
      console.error('Slow movers error:', err);
      return res.status(500).json({ error: err.message });
    }
    
    console.log('üìä Slow movers:', rows.length, 'pallets');
    res.json(rows || []);
  });
});

app.get('/api/bays', (req, res) => {
    db.all(`
        SELECT pb.*, 
        CASE 
            WHEN pb.status = 'on_hold' THEN 'on_hold'
            WHEN EXISTS (SELECT 1 FROM skus WHERE location = pb.location AND location_type = 'pallet') THEN 'occupied'
            ELSE 'empty'
        END as display_status
        FROM pallet_bays pb
    `, (err, rows) => {
        if (err) return res.status(500).json({ error: err.message });
        res.json(rows);
    });
});
// ============================================
// ALLOCATION QUEUE ENDPOINTS
// ============================================

app.get('/api/allocation/pending', (req, res) => {
    db.all(`
        SELECT sku_code, product_name, quantity, created_at
        FROM skus 
        WHERE location = 'UNALLOCATED' AND location_type = 'pending'
        ORDER BY created_at DESC
    `, (err, rows) => {
        if (err) {
            console.error('Error fetching allocation queue:', err);
            return res.status(500).json({ error: err.message });
        }
        console.log('Allocation queue:', rows.length, 'items');
        res.json(rows || []);
    });
});

app.post('/api/allocation/assign', (req, res) => {
    const { sku_code, location, location_type, quantity } = req.body;
    
    if (!sku_code || !location || !location_type) {
        return res.status(400).json({ error: 'SKU, location, and location_type required' });
    }
    
    console.log('Allocating:', sku_code, '‚Üí', location);
    
    // Update the unallocated item
    db.run(`UPDATE skus 
            SET location = ?, location_type = ?, quantity = ?
            WHERE sku_code = ? AND location = 'UNALLOCATED'`,
        [location, location_type, quantity || null, sku_code], function(err) {
        
        if (err) {
            console.error('Allocation error:', err);
            return res.status(500).json({ error: err.message });
        }
        
        if (this.changes === 0) {
            return res.status(404).json({ error: 'SKU not found in allocation queue' });
        }
        
        // Log the allocation
        db.run('INSERT INTO movement_history (from_location, to_location, sku_code, reason) VALUES (?, ?, ?, ?)',
            ['UNALLOCATED', location, sku_code, 'Initial allocation']);
        
        console.log('‚úì Allocated', sku_code, 'to', location);
        
        res.json({ success: true });
    });
});

app.post('/api/allocation/skip', (req, res) => {
    const { sku_code } = req.body;
    
    if (!sku_code) {
        return res.status(400).json({ error: 'SKU required' });
    }
    
    console.log('Skipping allocation:', sku_code);
    
    db.run(`DELETE FROM skus WHERE sku_code = ? AND location = 'UNALLOCATED'`,
        [sku_code], function(err) {
        
        if (err) {
            console.error('Skip error:', err);
            return res.status(500).json({ error: err.message });
        }
        
        console.log('‚úì Skipped', sku_code);
        
        res.json({ success: true, deleted: this.changes });
    });
});

app.get('/api/allocation/suggest-bay', (req, res) => {
    // Find empty bays, prefer lower levels (2, 3) and front aisles (AA, BB)
    db.all(`
        SELECT pb.location, pb.aisle, pb.level
        FROM pallet_bays pb
        WHERE pb.status = 'available'
        AND NOT EXISTS (SELECT 1 FROM skus WHERE location = pb.location AND location_type = 'pallet')
        ORDER BY 
            CASE pb.aisle 
                WHEN 'AA' THEN 1
                WHEN 'BB' THEN 2
                WHEN 'CC' THEN 3
                WHEN 'DD' THEN 4
                WHEN 'EE' THEN 5
                WHEN 'FF' THEN 6
            END,
            pb.level ASC,
            pb.bay_number ASC
        LIMIT 10
    `, (err, bays) => {
        if (err) {
            console.error('Suggest bay error:', err);
            return res.status(500).json({ error: err.message });
        }
        console.log('Suggested bays:', bays.length);
        res.json(bays || []);
    });
});

app.get('/api/bays/:location', (req, res) => {
    const { location } = req.params;
    
    console.log('Getting bay details for:', location);
    
    // Get bay info
    db.get('SELECT * FROM pallet_bays WHERE location = ?', [location], (err, bay) => {
        if (err) {
            console.error('Error fetching bay:', err);
            return res.status(500).json({ error: err.message });
        }
        
        if (!bay) {
            console.error('Bay not found:', location);
            return res.status(404).json({ error: 'Bay not found' });
        }
        
        // Get stock in this bay
        db.all('SELECT * FROM skus WHERE location = ? AND location_type = ?', 
            [location, 'pallet'], (err, stock) => {
            if (err) {
                console.error('Error fetching stock:', err);
                return res.status(500).json({ error: err.message });
            }
            
            console.log('Bay details:', bay, 'Stock:', stock ? stock.length : 0, 'items');
            
            res.json({ 
                bay: bay, 
                stock: stock || [] 
            });
        });
    });
});
app.get('/api/search', (req, res) => {
  const query = req.query.q;
  
  if (!query || query.length < 2) {
    return res.json([]);
  }
  
  const searchTerm = '%' + query + '%';
  
  // Search with proper grouping - shelf locations first, then pallets
  db.all(`
    SELECT 
      s.sku_code,
      s.product_name,
      s.location,
      s.location_type,
      s.quantity,
      CASE 
        WHEN s.location_type = 'shelf' THEN 1
        WHEN s.location_type = 'pallet' THEN 2
        ELSE 3
      END as sort_order
    FROM skus s
    WHERE (s.sku_code LIKE ? OR s.product_name LIKE ?)
      AND s.location != 'UNALLOCATED'
      AND (s.archived IS NULL OR s.archived = 0)
    ORDER BY s.sku_code, sort_order, s.location
    LIMIT 50
  `, [searchTerm, searchTerm], (err, rows) => {
    if (err) {
      console.error('Search error:', err);
      return res.status(500).json({ error: err.message });
    }
    
    // Always return an array, even if empty
    res.json(rows || []);
  });
});


app.post('/api/bays/:location/add-sku', (req, res) => {
    const { location } = req.params;
    const { sku_code, product_name, quantity } = req.body;
    db.run('INSERT INTO skus (location, location_type, sku_code, product_name, quantity) VALUES (?, ?, ?, ?, ?)',
        [location, 'pallet', sku_code, product_name, quantity || null], function(err) {
            if (err) return res.status(500).json({ error: err.message });
            res.json({ success: true });
        });
});

app.delete('/api/bays/:location/sku/:sku', (req, res) => {
    const location = req.params.location;
    const sku = decodeURIComponent(req.params.sku);
    
    console.log('üóëÔ∏è Deleting SKU:', sku, 'from', location);
    
    db.run('DELETE FROM skus WHERE location = ? AND sku_code = ?', 
        [location, sku], 
        function(err) {
            if (err) {
                console.error('‚ùå Delete error:', err);
                return res.status(500).json({ 
                    success: false, 
                    error: err.message 
                });
            }
            
            if (this.changes === 0) {
                console.error('‚ö†Ô∏è SKU not found');
                return res.status(404).json({ 
                    success: false, 
                    error: 'SKU not found in this location' 
                });
            }
            
            console.log('‚úÖ Deleted SKU:', sku, 'from', location, '- Rows deleted:', this.changes);
            
            // Log the deletion in movement history
            db.run('INSERT INTO movement_history (from_location, to_location, sku_code, reason) VALUES (?, ?, ?, ?)',
                [location, 'DELETED', sku, 'Manual deletion from bay'],
                (err) => {
                    if (err) console.error('Failed to log deletion:', err);
                }
            );
            
            res.json({ 
                success: true,
                message: sku + ' removed from ' + location
            });
        }
    );
});

app.put('/api/bays/:location/notes', (req, res) => {
    const { location } = req.params;
    const { notes } = req.body;
    db.run('UPDATE pallet_bays SET notes = ? WHERE location = ?', [notes, location], function(err) {
        if (err) return res.status(500).json({ error: err.message });
        res.json({ success: true });
    });
});
app.post('/api/bays/:location/update-qty', (req, res) => {
    const { location } = req.params;
    const { sku_code, quantity } = req.body;
    
    console.log('üìù Updating quantity:', sku_code, 'at', location, 'to', quantity);
    
    if(!sku_code){
        return res.status(400).json({ success: false, error: 'SKU code required' });
    }
    
    if(quantity === 0 || quantity === null) {
        // Delete if quantity is 0
        console.log('üóëÔ∏è Deleting SKU (quantity 0)');
        db.run('DELETE FROM skus WHERE location = ? AND location_type = ? AND sku_code = ?',
            [location, 'pallet', sku_code], function(err) {
                if(err) {
                    console.error('‚ùå Delete error:', err);
                    return res.status(500).json({ success: false, error: err.message });
                }
                
                if(this.changes === 0){
                    return res.status(404).json({ success: false, error: 'SKU not found at this location' });
                }
                
                console.log('‚úÖ SKU deleted successfully');
                
                // Log the deletion
                db.run('INSERT INTO movement_history (from_location, to_location, sku_code, reason) VALUES (?, ?, ?, ?)',
                    [location, 'REMOVED', sku_code, 'Quantity set to 0']);
                
                res.json({ success: true, deleted: true });
            });
    } else {
        // Update quantity
        console.log('üìä Updating quantity to', quantity);
        db.run('UPDATE skus SET quantity = ? WHERE location = ? AND location_type = ? AND sku_code = ?',
            [quantity, location, 'pallet', sku_code], function(err) {
                if(err) {
                    console.error('‚ùå Update error:', err);
                    return res.status(500).json({ success: false, error: err.message });
                }
                
                if(this.changes === 0) {
                    console.error('‚ö†Ô∏è SKU not found at location');
                    return res.status(404).json({ success: false, error: 'SKU not found at this location' });
                }
                
                console.log('‚úÖ Quantity updated successfully');
                
                // Log the change
                db.run('INSERT INTO movement_history (from_location, to_location, sku_code, reason) VALUES (?, ?, ?, ?)',
                    [location, location, sku_code, 'Quantity adjusted to ' + quantity]);
                
                res.json({ success: true, changes: this.changes });
            });
    }
});

app.post('/api/bays/:location/pick-all', (req, res) => {
    const { location } = req.params;
    const { reason } = req.body;
    db.get('SELECT MAX(CAST(SUBSTR(location, 6) AS INTEGER)) as max_num FROM hold_locations WHERE location LIKE "HOLD-%"', (err, row) => {
        const nextNum = (row.max_num || 0) + 1;
        const holdLocation = `HOLD-${String(nextNum).padStart(3, '0')}`;
        db.run('INSERT INTO hold_locations (location, original_bay, reason) VALUES (?, ?, ?)', [holdLocation, location, reason], function(err) {
            if (err) return res.status(500).json({ error: err.message });
            db.run('UPDATE skus SET location = ?, location_type = ? WHERE location = ? AND location_type = ?',
                [holdLocation, 'hold', location, 'pallet'], function(err) {
                    if (err) return res.status(500).json({ error: err.message });
                    db.run('UPDATE pallet_bays SET status = ? WHERE location = ?', ['on_hold', location], function(err) {
                        if (err) return res.status(500).json({ error: err.message });
                        db.run('INSERT INTO movement_history (from_location, to_location, reason) VALUES (?, ?, ?)',
                            [location, holdLocation, reason]);
                        res.json({ success: true, hold_location: holdLocation });
                    });
                });
        });
    });
});


// Search endpoint for main search feature
app.get('/api/search/:term', (req, res) => {
    const term = req.params.term.toLowerCase();
    
    if (!term || term.length < 2) {
        return res.json([]);
    }
    
    const searchTerm = '%' + term + '%';
    
    // Search with bay validation
    db.all(`SELECT 
                s.location,
                s.location_type,
                s.sku_code,
                s.product_name,
                s.quantity,
                CASE 
                    WHEN s.location_type = 'pallet' THEN 
                        (SELECT COUNT(*) FROM pallet_bays WHERE location = s.location)
                    ELSE 1
                END as bay_exists
            FROM skus s
           WHERE (LOWER(s.sku_code) LIKE ? OR LOWER(s.product_name) LIKE ? OR LOWER(s.location) LIKE ?)
           AND s.location != 'UNALLOCATED'
           AND s.active = 1
           AND s.archived = 0  
            ORDER BY s.location, s.sku_code`,
        [searchTerm, searchTerm, searchTerm],
        (err, rows) => {
            if (err) {
                console.error('Search error:', err);
                return res.status(500).json({ error: err.message });
            }
            
            // Filter out non-existent bays
            const validRows = rows.filter(row => {
                if (row.location_type === 'pallet' && row.bay_exists === 0) {
                    console.log('üóëÔ∏è Filtering out non-existent bay:', row.location);
                    return false;
                }
                return true;
            });
            
            // Group by location
            const grouped = {};
            validRows.forEach(row => {
                if (!grouped[row.location]) {
                    grouped[row.location] = {
                        location: row.location,
                        locationType: row.location_type,
                        skus: []
                    };
                }
                grouped[row.location].skus.push({
                    code: row.sku_code,
                    name: row.product_name,
                    quantity: row.quantity
                });
            });
            
            const results = Object.values(grouped);
            console.log('‚úÖ Search results (after filtering):', results.length, 'locations');
            
            res.json(results);
        }
    );
});

app.get('/api/products/all', (req, res) => {
    db.all(`
        SELECT sku_code, product_name, location, location_type, quantity 
        FROM skus 
        ORDER BY sku_code, location
    `, (err, rows) => {
        if (err) return res.status(500).json({ error: err.message });
        res.json(rows || []);
    });
});
app.get('/api/products', (req, res) => {
    console.log('Fetching all products...');
    
    db.all(`
        SELECT 
            sku_code, 
            product_name, 
            location, 
            location_type, 
            quantity,
            created_at
        FROM skus 
        ORDER BY sku_code, location
    `, (err, rows) => {
        if (err) {
            console.error('Error fetching products:', err);
            return res.status(500).json({ error: err.message });
        }
        
        console.log('‚úÖ Returned', rows.length, 'product records');
        res.json(rows || []);
    });
});

// Existing search endpoint below
app.get('/api/products/search/:term', (req, res) => {
    // ... existing code ...
});

app.get('/api/products/search/:term', (req, res) => {
    const term = '%' + req.params.term + '%';
    db.all(`
        SELECT sku_code, product_name, location, location_type, quantity 
        FROM skus 
        WHERE sku_code LIKE ? OR product_name LIKE ?
        ORDER BY sku_code, location
    `, [term, term], (err, rows) => {
        if (err) return res.status(500).json({ error: err.message });
        res.json(rows || []);
    });
});

app.get('/api/bundles', (req, res) => {
    db.all('SELECT * FROM bundles ORDER BY bundle_code', (err, rows) => {
        if (err) return res.status(500).json({ error: err.message });
        res.json(rows || []);
    });
});

app.get('/api/bundle/:code', (req, res) => {
    const { code } = req.params;
    db.all('SELECT * FROM bundle_components WHERE bundle_code = ?', [code], (err, components) => {
        if (err) return res.status(500).json({ error: err.message });
        const result = { components: [] };
        if (components.length === 0) return res.json(result);
        let completed = 0;
        components.forEach(comp => {
            db.all('SELECT location, location_type, quantity FROM skus WHERE sku_code = ?', [comp.component_sku], (err, locations) => {
                db.get('SELECT product_name FROM skus WHERE sku_code = ? LIMIT 1', [comp.component_sku], (err, product) => {
                    result.components.push({
                        sku: comp.component_sku,
                        productName: product ? product.product_name : '',
                        quantityNeeded: comp.quantity_needed,
                        locations: locations || []
                    });
                    completed++;
                    if (completed === components.length) res.json(result);
                });
            });
        });
    });
});

app.get('/api/holds', (req, res) => {
    db.all(`SELECT hl.*, COUNT(s.id) as sku_count,
            GROUP_CONCAT(s.sku_code || ' (' || COALESCE(s.quantity, 'N/A') || ')', ', ') as sku_list
            FROM hold_locations hl 
            LEFT JOIN skus s ON s.location = hl.location AND s.location_type = 'hold'
            WHERE hl.status = 'active'
            GROUP BY hl.location
            ORDER BY hl.created_at DESC`, (err, rows) => {
        if (err) return res.status(500).json({ error: err.message });
        res.json(rows || []);
    });
});
app.post('/api/holds/create', (req, res) => {
    const { bay_location, reason } = req.body;
    
    const holdLocation = `HOLD-${bay_location}`;
    
    console.log('Creating hold for bay:', bay_location, 'Hold location:', holdLocation);
    
    // Check if this BAY already has an active hold (check by original_bay, not location)
    db.get('SELECT location, status FROM hold_locations WHERE original_bay = ? AND status = ?', 
        [bay_location, 'active'], (err, existing) => {
        if (err) {
            console.error('Error checking existing hold:', err);
            return res.status(500).json({ error: err.message });
        }
        
        if (existing) {
            console.log('Bay already has an active hold:', existing.location);
            return res.status(400).json({ 
                error: 'This bay is already on hold at ' + existing.location 
            });
        }
        
        // Create new hold location
        db.run('INSERT INTO hold_locations (location, original_bay, reason, status) VALUES (?, ?, ?, ?)', 
            [holdLocation, bay_location, reason, 'active'], function(err) {
            if (err) {
                console.error('Error creating hold location:', err);
                return res.status(500).json({ error: err.message });
            }
            
            console.log('Hold location created, now moving stock...');
            
            // Move all stock from the bay to the hold location
            db.run('UPDATE skus SET location = ?, location_type = ? WHERE location = ? AND location_type = ?',
                [holdLocation, 'hold', bay_location, 'pallet'], function(err) {
                if (err) {
                    console.error('Error moving stock to hold:', err);
                    return res.status(500).json({ error: err.message });
                }
                
                const skusMovedCount = this.changes;
                console.log('Moved', skusMovedCount, 'SKUs to hold');
                
                // Update bay status
                db.run('UPDATE pallet_bays SET status = ? WHERE location = ?', ['on_hold', bay_location], function(err) {
                    if (err) {
                        console.error('Error updating bay status:', err);
                        return res.status(500).json({ error: err.message });
                    }
                    
                    // Log the movement
                    db.run('INSERT INTO movement_history (from_location, to_location, reason) VALUES (?, ?, ?)',
                        [bay_location, holdLocation, reason || 'Placed on hold']);
                    
                    console.log('Hold created successfully');
                    res.json({ 
                        success: true, 
                        hold_location: holdLocation, 
                        skus_moved: skusMovedCount 
                    });
                });
            });
        });
    });
});

app.post('/api/import-shelf-stock', upload.single('file'), (req, res) => {
    const filePath = req.file.path;
    const fileContent = fs.readFileSync(filePath, 'utf-8');
    const lines = fileContent.split('\n').filter(line => line.trim());
    
    if (lines.length === 0) {
        fs.unlinkSync(filePath);
        return res.json({ success: false, message: 'File is empty' });
    }

    // Skip header row if it exists
    let startLine = 0;
    if (lines[0].toLowerCase().includes('sku') || lines[0].toLowerCase().includes('name') || lines[0].toLowerCase().includes('warehouse')) {
        startLine = 1;
    }

    const dataLines = lines.slice(startLine);
    let imported = 0;
    let updated = 0;
    let skipped = 0;
    
    // Process each line
    let processed = 0;
    
    dataLines.forEach(line => {
        const parts = line.split('\t');
        
        // Format: SKU [TAB] Name [TAB] WarehouseLocation
        if (parts.length >= 3) {
            const sku = parts[0].trim();
            const productName = parts[1].trim();
            const location = parts[2].trim();
            
            if (sku && productName && location) {
                // Check if already exists
                db.get('SELECT * FROM skus WHERE sku_code = ? AND location = ? AND location_type = ?',
                    [sku, location, 'shelf'], (err, existing) => {
                    
                    if(existing){
                        // Already exists - update product name if different
                        if(existing.product_name !== productName){
                            db.run('UPDATE skus SET product_name = ? WHERE sku_code = ? AND location = ? AND location_type = ?',
                                [productName, sku, location, 'shelf'], (err) => {
                                if(!err) updated++;
                                checkComplete();
                            });
                        }else{
                            skipped++;
                            checkComplete();
                        }
                    }else{
                        // New entry - insert
                        db.run('INSERT INTO skus (location, location_type, sku_code, product_name, quantity) VALUES (?, ?, ?, ?, ?)',
                            [location, 'shelf', sku, productName, null], function(err) {
                            if(!err) imported++;
                            checkComplete();
                        });
                    }
                });
            }else{
                checkComplete();
            }
        }else{
            checkComplete();
        }
        
        function checkComplete(){
            processed++;
            if(processed === dataLines.length){
                fs.unlinkSync(filePath);
                res.json({ 
                    success: true, 
                    message: `Import complete: ${imported} new, ${updated} updated, ${skipped} skipped (already exists)`,
                    imported: imported,
                    updated: updated,
                    skipped: skipped
                });
            }
        }
    });
});

app.post('/api/import-bundles', upload.single('file'), (req, res) => {
    if (!req.file) {
        return res.status(400).json({ success: false, message: 'No file uploaded' });
    }
    try {
        const fileContent = req.file.buffer.toString('utf-8');
        const lines = fileContent.split('\n').filter(line => line.trim());
        
        console.log('Processing bundle import:', lines.length, 'lines');
        
        if (lines.length === 0) {
            return res.json({ success: false, message: 'File is empty' });
        }
        
        // Skip header row if it exists
        let startLine = 0;
        const firstLine = lines[0].toLowerCase();
        if (firstLine.includes('bundle') || firstLine.includes('component') || firstLine.includes('sku')) {
            startLine = 1;
            console.log('Skipping header row');
        }
        
        const dataLines = lines.slice(startLine);
        let imported = 0;
        let skipped = 0;
        let updated = 0;
        let errors = [];
        
        // Group components by bundle first
        const bundleMap = {};
        
        dataLines.forEach((line, index) => {
            const parts = line.split('\t');
            
            // Format: BundleCode [TAB] BundleName [TAB] ComponentSKU [TAB] ComponentName [TAB] Quantity
            if (parts.length >= 3) {
                const bundleCode = parts[0].trim();
                const bundleName = parts[1].trim();
                const componentSku = parts[2].trim();
                const qty = parts.length >= 5 ? (parseInt(parts[4].trim()) || 1) : 1;
                
                if (bundleCode && componentSku) {
                    if (!bundleMap[bundleCode]) {
                        bundleMap[bundleCode] = {
                            name: bundleName,
                            components: []
                        };
                    }
                    bundleMap[bundleCode].components.push({
                        sku: componentSku,
                        quantity: qty
                    });
                } else {
                    skipped++;
                }
            } else {
                console.log('Invalid line format:', line);
                skipped++;
            }
        });
        
        console.log('Found', Object.keys(bundleMap).length, 'unique bundles');
        
        // Process bundles one at a time
        db.serialize(() => {
            db.run('BEGIN TRANSACTION');
            
            Object.keys(bundleMap).forEach(bundleCode => {
                const bundle = bundleMap[bundleCode];
                
                // Check if bundle exists
                db.get('SELECT * FROM bundles WHERE bundle_code = ?', [bundleCode], (err, existingBundle) => {
                    if (existingBundle) {
                        // BUNDLE EXISTS - CLEAR OLD COMPONENTS FIRST
                        db.run('DELETE FROM bundle_components WHERE bundle_code = ?', [bundleCode], (err) => {
                            if (err) {
                                console.error('Error clearing components for', bundleCode, ':', err.message);
                                errors.push(`${bundleCode}: Failed to clear old components`);
                                return;
                            }
                            
                            console.log('üóëÔ∏è Cleared old components for bundle:', bundleCode);
                            
                            // Now insert new components
                            bundle.components.forEach(comp => {
                                db.run('INSERT INTO bundle_components (bundle_code, component_sku, quantity_needed) VALUES (?, ?, ?)',
                                    [bundleCode, comp.sku, comp.quantity],
                                    (err) => {
                                        if (err) {
                                            console.error('Error inserting component:', err.message);
                                            errors.push(`${bundleCode} -> ${comp.sku}: ${err.message}`);
                                        } else {
                                            imported++;
                                        }
                                    }
                                );
                            });
                            
                            updated++;
                            console.log(`‚úÖ Updated bundle: ${bundleCode} with ${bundle.components.length} components`);
                        });
                    } else {
                        // NEW BUNDLE - CREATE IT
                        db.run('INSERT INTO bundles (bundle_code, bundle_name) VALUES (?, ?)',
                            [bundleCode, bundle.name],
                            (err) => {
                                if (err) {
                                    console.error('Error creating bundle:', err.message);
                                    errors.push(`${bundleCode}: ${err.message}`);
                                    return;
                                }
                                
                                // Insert components
                                bundle.components.forEach(comp => {
                                    db.run('INSERT INTO bundle_components (bundle_code, component_sku, quantity_needed) VALUES (?, ?, ?)',
                                        [bundleCode, comp.sku, comp.quantity],
                                        (err) => {
                                            if (err) {
                                                console.error('Error inserting component:', err.message);
                                                errors.push(`${bundleCode} -> ${comp.sku}: ${err.message}`);
                                            } else {
                                                imported++;
                                            }
                                        }
                                    );
                                });
                                
                                console.log(`‚úÖ Created new bundle: ${bundleCode} with ${bundle.components.length} components`);
                            }
                        );
                    }
                });
            });
            
            // Wait for all operations to complete, then commit
            setTimeout(() => {
                db.run('COMMIT', (err) => {
                    if (err) {
                        console.error('Commit error:', err);
                        db.run('ROLLBACK');
                        return res.status(500).json({ 
                            success: false, 
                            message: 'Database error: ' + err.message 
                        });
                    }
                    
                    console.log('Bundle import complete:', imported, 'components imported,', updated, 'bundles updated,', skipped, 'skipped');
                    
                    res.json({ 
                        success: true, 
                        message: `Imported ${imported} components, updated ${updated} bundles${skipped > 0 ? `, skipped ${skipped}` : ''}`,
                        imported: imported,
                        updated: updated,
                        skipped: skipped,
                        errors: errors.length > 0 ? errors.slice(0, 10) : undefined
                    });
                });
            }, 2000); // Wait 2 seconds for async operations
        });
        
    } catch (err) {
        console.error('Bundle import error:', err);
        res.status(500).json({ 
            success: false, 
            message: 'Import failed: ' + err.message 
        });
    }
});

app.get('/api/skus/search', (req, res) => {
    const term = req.query.q;
    if (!term || term.length < 2) {
        return res.json([]);
    }
    db.all(
        `SELECT DISTINCT sku_code, product_name
         FROM skus
         WHERE (sku_code LIKE ? OR product_name LIKE ?)
           AND active = 1
         LIMIT 20`,
        ['%' + term + '%', '%' + term + '%'],
        (err, rows) => {
            if (err) return res.status(500).json({ error: err.message });
            res.json(rows || []);
        }
    );
});

app.get('/api/dashboard/recent-activity', (req, res) => {
    db.all('SELECT * FROM movement_history ORDER BY moved_at DESC LIMIT 10', (err, rows) => {
        if (err) return res.status(500).json({ error: err.message });
        res.json(rows || []);
    });
});

app.post('/api/cleanup-duplicates', (req, res) => {
    // Only removes TRUE duplicates: same SKU + same location + same type
    db.run(`DELETE FROM skus 
            WHERE id NOT IN (
                SELECT MIN(id) 
                FROM skus 
                GROUP BY location, location_type, sku_code
            )`,
        function(err) {
            if (err) return res.status(500).json({ error: err.message });
            res.json({ 
                success: true, 
                message: 'Removed ' + this.changes + ' duplicate entries (same SKU in same location)'
            });
        });
});

app.post('/api/cleanup-bundle-duplicates', (req, res) => {
    db.run(`DELETE FROM bundle_components 
            WHERE id NOT IN (
                SELECT MIN(id) 
                FROM bundle_components 
                GROUP BY bundle_code, component_sku, quantity_needed
            )`, function(err) {
        if (err) return res.status(500).json({ error: err.message });
        res.json({ success: true, message: 'Removed ' + this.changes + ' duplicate bundle components' });
    });
});

app.get('/api/holds/:location', (req, res) => {
    const { location } = req.params;
    db.get('SELECT * FROM hold_locations WHERE location = ?', [location], (err, hold) => {
        if (err) return res.status(500).json({ error: err.message });
        if (!hold) return res.status(404).json({ error: 'Hold not found' });
        db.all('SELECT * FROM skus WHERE location = ? AND location_type = ?', [location, 'hold'], (err, stock) => {
            if (err) return res.status(500).json({ error: err.message });
            res.json({ hold, stock: stock || [] });
        });
    });
});

app.post('/api/holds/:location/add-sku', (req, res) => {
    const { location } = req.params;
    const { sku_code, product_name, quantity } = req.body;
    db.run('INSERT INTO skus (location, location_type, sku_code, product_name, quantity) VALUES (?, ?, ?, ?, ?)',
        [location, 'hold', sku_code, product_name, quantity || null], function(err) {
            if (err) return res.status(500).json({ error: err.message });
            res.json({ success: true });
        });
});


// Return hold to original bay
app.post('/api/holds/:holdId/return', (req, res) => {
    const holdId = decodeURIComponent(req.params.holdId);
    
    console.log('üì¶ Returning hold to bay:', holdId);
    
    // Get hold details
    db.get('SELECT * FROM hold_locations WHERE location = ?', [holdId], (err, hold) => {
        if (err) {
            console.error('‚ùå Database error:', err);
            return res.status(500).json({ error: err.message });
        }
        
        if (!hold) {
            console.error('‚ùå Hold not found:', holdId);
            return res.status(404).json({ error: 'Hold not found' });
        }
        
        const originalBay = hold.original_bay;
        
        if (!originalBay) {
            return res.status(400).json({ error: 'No original bay recorded' });
        }
        
        // Check if original bay is available
        db.get('SELECT * FROM pallet_bays WHERE location = ?', [originalBay], (err, bay) => {
            if (err || !bay) {
                return res.status(400).json({ error: 'Original bay not found' });
            }
            
            // Get all stock in hold
            db.all('SELECT * FROM skus WHERE location = ? AND location_type = ?', 
                [holdId, 'hold'], (err, holdStock) => {
                
                if (err) {
                    console.error('‚ùå Error loading hold stock:', err);
                    return res.status(500).json({ error: err.message });
                }
                
                if (!holdStock || holdStock.length === 0) {
                    console.log('‚ö†Ô∏è No stock in hold, just releasing');
                    
                    // Delete hold and update bay status
                    db.run('DELETE FROM hold_locations WHERE location = ?', [holdId], (err) => {
                        db.run('UPDATE pallet_bays SET status = ? WHERE location = ?', 
                            ['empty', originalBay], (err) => {
                            
                            console.log('‚úÖ Empty hold released');
                            return res.json({ success: true, original_bay: originalBay });
                        });
                    });
                    return;
                }
                
                console.log(`üì¶ Moving ${holdStock.length} items back to ${originalBay}`);
                
                // Move all stock back to original bay
                db.serialize(() => {
                    db.run('BEGIN TRANSACTION');
                    
                    let completed = 0;
                    let errors = [];
                    
                    holdStock.forEach(stock => {
                        // Check if SKU already exists in bay
                        db.get('SELECT * FROM skus WHERE location = ? AND location_type = ? AND sku_code = ?',
                            [originalBay, 'pallet', stock.sku_code], (err, existing) => {
                            
                            if (existing) {
                                // Merge quantities
                                const newQty = (existing.quantity || 0) + (stock.quantity || 0);
                                db.run('UPDATE skus SET quantity = ? WHERE location = ? AND location_type = ? AND sku_code = ?',
                                    [newQty, originalBay, 'pallet', stock.sku_code], (err) => {
                                    
                                    if (err) errors.push(stock.sku_code + ': ' + err.message);
                                    checkComplete();
                                });
                            } else {
                                // Insert new
                                db.run('INSERT INTO skus (location, location_type, sku_code, product_name, quantity) VALUES (?, ?, ?, ?, ?)',
                                    [originalBay, 'pallet', stock.sku_code, stock.product_name, stock.quantity], (err) => {
                                    
                                    if (err) errors.push(stock.sku_code + ': ' + err.message);
                                    checkComplete();
                                });
                            }
                        });
                    });
                    
                    function checkComplete() {
                        completed++;
                        
                        if (completed === holdStock.length) {
                            if (errors.length > 0) {
                                db.run('ROLLBACK');
                                return res.status(500).json({ error: 'Errors: ' + errors.join(', ') });
                            }
                            
                            // Delete stock from hold
                            db.run('DELETE FROM skus WHERE location = ? AND location_type = ?', 
                                [holdId, 'hold'], (err) => {
                                
                                // Delete hold record
                                db.run('DELETE FROM hold_locations WHERE location = ?', [holdId], (err) => {
                                    
                                    // Update bay status
                                    db.run('UPDATE pallet_bays SET status = ? WHERE location = ?', 
                                        ['occupied', originalBay], (err) => {
                                        
                                        db.run('COMMIT', (err) => {
                                            console.log('‚úÖ Hold returned successfully');
                                            res.json({ 
                                                success: true, 
                                                original_bay: originalBay,
                                                items_moved: holdStock.length
                                            });
                                        });
                                    });
                                });
                            });
                        }
                    }
                });
            });
        });
    });
});



app.delete('/api/holds/:location/sku/:sku', (req, res) => {
    const { location, sku } = req.params;
    db.run('DELETE FROM skus WHERE location = ? AND location_type = ? AND sku_code = ?',
        [location, 'hold', sku], function(err) {
            if (err) return res.status(500).json({ error: err.message });
            res.json({ success: true });
        });
});

app.put('/api/holds/:location/notes', (req, res) => {
    const { location } = req.params;
    const { reason } = req.body;
    db.run('UPDATE hold_locations SET reason = ? WHERE location = ?', [reason, location], function(err) {
        if (err) return res.status(500).json({ error: err.message });
        res.json({ success: true });
    });
});

// Update hold stock quantity
app.post('/api/holds/:holdId/update-qty', (req, res) => {
    const holdId = decodeURIComponent(req.params.holdId);
    const { sku_code, quantity } = req.body;
    
    console.log('üìù Update hold qty:', { holdId, sku_code, quantity });
    
    // First verify the hold exists
    db.get('SELECT * FROM hold_locations WHERE location = ?', [holdId], (err, hold) => {
        if (err) {
            console.error('‚ùå Database error:', err);
            return res.status(500).json({ error: err.message });
        }
        
        if (!hold) {
            console.error('‚ùå Hold not found:', holdId);
            return res.status(404).json({ error: 'Hold bay not found' });
        }
        
        // Find the stock item
        db.get('SELECT * FROM skus WHERE location = ? AND location_type = ? AND sku_code = ?',
            [holdId, 'hold', sku_code], (err, stockItem) => {
            
            if (err) {
                console.error('‚ùå Database error:', err);
                return res.status(500).json({ error: err.message });
            }
            
            if (!stockItem) {
                console.error('‚ùå SKU not found in hold:', sku_code);
                return res.status(404).json({ error: 'SKU not found in hold' });
            }
            
            if (quantity === 0) {
                // Remove the item
                console.log('üóëÔ∏è Removing', sku_code, 'from hold');
                
                db.run('DELETE FROM skus WHERE location = ? AND location_type = ? AND sku_code = ?',
                    [holdId, 'hold', sku_code], function(err) {
                    
                    if (err) {
                        console.error('‚ùå Delete error:', err);
                        return res.status(500).json({ error: err.message });
                    }
                    
                    console.log('‚úÖ Item removed from hold');
                    
                    // Check if hold is now empty
                    db.get('SELECT COUNT(*) as count FROM skus WHERE location = ? AND location_type = ?',
                        [holdId, 'hold'], (err, result) => {
                        
                        if (err) {
                            console.error('‚ö†Ô∏è Error checking hold status:', err);
                            // Still return success for the delete
                            return res.json({ success: true, deleted: true });
                        }
                        
                        if (result.count === 0) {
                            console.log('üîì Hold is empty, releasing hold and bay');
                            
                            // Get original bay
                            const originalBay = hold.original_bay;
                            
                            // Delete the hold record
                            db.run('DELETE FROM hold_locations WHERE location = ?', [holdId], (err) => {
                                if (err) console.error('‚ö†Ô∏è Error deleting hold:', err);
                                
                                // Update bay status back to empty/available
                                if (originalBay) {
                                    db.run('UPDATE pallet_bays SET status = ? WHERE location = ?',
                                        ['empty', originalBay], (err) => {
                                        if (err) console.error('‚ö†Ô∏è Error updating bay:', err);
                                        
                                        console.log('‚úÖ Bay released:', originalBay);
                                        res.json({ success: true, deleted: true, holdReleased: true });
                                    });
                                } else {
                                    res.json({ success: true, deleted: true, holdReleased: true });
                                }
                            });
                        } else {
                            // Hold still has items
                            res.json({ success: true, deleted: true });
                        }
                    });
                });
            } else {
                // Update quantity
                console.log('‚úèÔ∏è Updating qty to', quantity);
                
                db.run('UPDATE skus SET quantity = ? WHERE location = ? AND location_type = ? AND sku_code = ?',
                    [parseInt(quantity), holdId, 'hold', sku_code], function(err) {
                    
                    if (err) {
                        console.error('‚ùå Update error:', err);
                        return res.status(500).json({ error: err.message });
                    }
                    
                    console.log('‚úÖ Quantity updated');
                    
                    // Return updated item
                    db.get('SELECT * FROM skus WHERE location = ? AND location_type = ? AND sku_code = ?',
                        [holdId, 'hold', sku_code], (err, updatedItem) => {
                        
                        if (err) {
                            return res.json({ success: true });
                        }
                        
                        res.json({ success: true, item: updatedItem });
                    });
                });
            }
        });
    });
});



// Export full inventory
app.get('/api/reports/inventory-export', (req, res) => {
    db.all(`SELECT location, location_type, sku_code, product_name, quantity
            FROM skus
            WHERE location != 'UNALLOCATED'
            AND active = 1
            AND archived = 0
            ORDER BY location, sku_code`,
        (err, rows) => {
            if (err) {
                console.error('Export error:', err);
                return res.status(500).json({ error: err.message });
            }
            
            res.json(rows || []);
        }
    );
});

// Stock by aisle report
app.get('/api/reports/stock-by-aisle', (req, res) => {
    db.all(`SELECT 
                SUBSTR(pb.location, 1, 2) as aisle,
                COUNT(DISTINCT s.sku_code) as total_skus,
                COUNT(DISTINCT CASE WHEN s.sku_code IS NOT NULL THEN pb.location END) as occupied_bays,
                COUNT(DISTINCT CASE WHEN s.sku_code IS NULL THEN pb.location END) as empty_bays
            FROM pallet_bays pb
            LEFT JOIN skus s ON s.location = pb.location AND s.location_type = 'pallet'
            GROUP BY aisle
            ORDER BY aisle`,
        (err, rows) => {
            if (err) {
                console.error('Aisle report error:', err);
                return res.status(500).json({ error: err.message });
            }
            
            res.json(rows || []);
        }
    );
});

// Aisle detail report
app.get('/api/reports/aisle-detail/:aisle', (req, res) => {
    const { aisle } = req.params;
    
    db.all(`SELECT location, sku_code, product_name, quantity
            FROM skus
            WHERE location LIKE ? 
            AND location_type = 'pallet'
            AND active = 1
            AND archived = 0
            ORDER BY location, sku_code`,
        [aisle + '%'],
        (err, rows) => {
            if (err) {
                console.error('Aisle detail error:', err);
                return res.status(500).json({ error: err.message });
            }
            
            res.json(rows || []);
        }
    );
});
// Admin: Find bad locations
app.get('/api/admin/bad-locations', (req, res) => {
    db.all(`
        SELECT location, sku_code, product_name, location_type
        FROM skus
        WHERE location_type='pallet' 
        AND SUBSTR(location, 1, 2) NOT IN ('AA','BB','CC','DD','EE','FF')
        ORDER BY location
    `, (err, rows) => {
        if (err) return res.status(500).json({ error: err.message });
        res.json(rows);
    });
});

// Admin: Delete bad location
app.post('/api/admin/delete-bad-location', (req, res) => {
    const { location, sku_code } = req.body;// Restore a backup

    db.run('DELETE FROM skus WHERE location = ? AND sku_code = ?', [location, sku_code], function(err) {
        if (err) return res.status(500).json({ error: err.message });
        res.json({ success: true, deleted: this.changes });
    });
});
// Admin: Add active status column to SKUs
app.get('/api/admin/add-sku-status-column', (req, res) => {
    db.run(`ALTER TABLE skus ADD COLUMN active INTEGER DEFAULT 1`, (err) => {
        if (err) {
            // Column might already exist
            if (err.message.includes('duplicate column')) {
                return res.json({ 
                    success: true, 
                    message: 'Column already exists' 
                });
            }
            console.error('Error adding column:', err);
            return res.status(500).json({ error: err.message });
        }
        
        console.log('‚úÖ Added active column to skus table');
        
        res.json({ 
            success: true, 
            message: 'Active status column added successfully' 
        });
    });
});
// Get all deactivated SKUs
app.get('/api/admin/deactivated-skus', (req, res) => {
    db.all(`SELECT sku_code, product_name, COUNT(*) as location_count, SUM(quantity) as total_quantity
            FROM skus 
            WHERE active = 0
            GROUP BY sku_code
            ORDER BY sku_code`,
        (err, skus) => {
            if (err) {
                console.error('Error fetching deactivated SKUs:', err);
                return res.status(500).json({ error: err.message });
            }
            
            res.json(skus || []);
        }
    );
});

// Deactivate a SKU
app.post('/api/admin/deactivate-sku', (req, res) => {
    const { sku_code } = req.body;
    
    if (!sku_code) {
        return res.status(400).json({ error: 'SKU code required' });
    }
    
    db.run(`UPDATE skus SET active = 0 WHERE sku_code = ?`,
        [sku_code],
        function(err) {
            if (err) {
                console.error('Error deactivating SKU:', err);
                return res.status(500).json({ error: err.message });
            }
            
            console.log('üö´ Deactivated SKU:', sku_code, '- Affected', this.changes, 'records');
            
            res.json({ 
                success: true,
                sku_code: sku_code,
                records_affected: this.changes
            });
        }
    );
});

// Reactivate a SKU
app.post('/api/admin/reactivate-sku', (req, res) => {
    const { sku_code } = req.body;
    
    if (!sku_code) {
        return res.status(400).json({ error: 'SKU code required' });
    }
    
    db.run(`UPDATE skus SET active = 1 WHERE sku_code = ?`,
        [sku_code],
        function(err) {
            if (err) {
                console.error('Error reactivating SKU:', err);
                return res.status(500).json({ error: err.message });
            }
            
            console.log('‚úÖ Reactivated SKU:', sku_code, '- Affected', this.changes, 'records');
            
            res.json({ 
                success: true,
                sku_code: sku_code,
                records_affected: this.changes
            });
        }
    );
});

// Edit SKU details
app.post('/api/admin/edit-sku', (req, res) => {
    const { old_sku_code, new_sku_code, new_product_name } = req.body;
    
    if (!old_sku_code) {
        return res.status(400).json({ error: 'Original SKU code required' });
    }
    
    // Build update query based on what's being changed
    let updateFields = [];
    let updateValues = [];
    
    if (new_sku_code && new_sku_code !== old_sku_code) {
        updateFields.push('sku_code = ?');
        updateValues.push(new_sku_code);
    }
    
    if (new_product_name) {
        updateFields.push('product_name = ?');
        updateValues.push(new_product_name);
    }
    
    if (updateFields.length === 0) {
        return res.status(400).json({ error: 'No changes specified' });
    }
    
    updateValues.push(old_sku_code); // For WHERE clause
    
    db.run(`UPDATE skus SET ${updateFields.join(', ')} WHERE sku_code = ?`,
        updateValues,
        function(err) {
            if (err) {
                console.error('Error updating SKU:', err);
                return res.status(500).json({ error: err.message });
            }
            
            console.log('‚úèÔ∏è Updated SKU:', old_sku_code, '‚Üí', new_sku_code || old_sku_code, '- Affected', this.changes, 'records');
            
            res.json({ 
                success: true,
                old_sku: old_sku_code,
                new_sku: new_sku_code || old_sku_code,
                records_affected: this.changes
            });
        }
    );
});

// Replace old SKU with new SKU in all locations
app.post('/api/admin/replace-sku', (req, res) => {
    const { old_sku_code, new_sku_code, new_product_name } = req.body;
    
    if (!old_sku_code || !new_sku_code) {
        return res.status(400).json({ error: 'Both old and new SKU codes required' });
    }
    
    db.run(`UPDATE skus 
            SET sku_code = ?, product_name = COALESCE(?, product_name)
            WHERE sku_code = ?`,
        [new_sku_code, new_product_name, old_sku_code],
        function(err) {
            if (err) {
                console.error('Error replacing SKU:', err);
                return res.status(500).json({ error: err.message });
            }
            
            console.log('üîÑ Replaced', old_sku_code, 'with', new_sku_code, '- Affected', this.changes, 'records');
            
            res.json({ 
                success: true,
                old_sku: old_sku_code,
                new_sku: new_sku_code,
                records_affected: this.changes
            });
        }
    );
});

// Admin: Clean up orphaned holds
app.post('/api/admin/cleanup-holds', (req, res) => {
    // Delete holds that have no stock
    db.run(`
        DELETE FROM hold_locations 
        WHERE location NOT IN (
            SELECT DISTINCT location FROM skus WHERE location_type='hold'
        )
    `, function(err) {
        if (err) {
            console.error('Error cleaning holds:', err);
            return res.status(500).json({ error: err.message });
        }
        console.log('Cleaned up', this.changes, 'orphaned holds');
        res.json({ success: true, cleaned: this.changes });
    });
});
// Receiving API with smart centralized bay suggestions
app.post('/api/receiving/analyze', (req, res) => {
    const { items } = req.body;
    const result = {
        shelfItems: [],
        palletItems: [],
        totalItems: items.length
    };
    
    let processed = 0;
    const shelfAisles = []; // Collect all shelf aisles for central calculation
    
    items.forEach(item => {
        // Check if SKU already exists
        db.get(`SELECT location, location_type, product_name FROM skus 
                WHERE sku_code = ? 
                ORDER BY CASE WHEN location_type='shelf' THEN 0 ELSE 1 END
                LIMIT 1`, 
            [item.sku], (err, existing) => {
            
            if (existing && existing.location_type === 'shelf') {
                // Has shelf location - add to shelf items
                result.shelfItems.push({
                    sku: item.sku,
                    qty: item.qty,
                    product_name: existing.product_name || item.sku,
                    existing_location: existing.location
                });
                
                // Collect aisle for central calculation
                const shelfAisle = existing.location.substring(0, 2);
                shelfAisles.push(shelfAisle);
            } else {
                // Needs pallet bay
                result.palletItems.push({
                    sku: item.sku,
                    qty: item.qty,
                    product_name: existing ? existing.product_name : item.sku,
                    shelf_aisle: null // Will be determined later
                });
            }
            
            processed++;
            
            // Once all items processed, calculate optimal bay locations
            if (processed === items.length) {
                if (result.palletItems.length > 0) {
                    calculateOptimalBays(shelfAisles, result, res);
                } else {
                    res.json(result);
                }
            }
        });
    });
});
// ============================================
// ARCHIVE MANAGEMENT
// ============================================

// Archive a SKU (prevents re-import)
app.post('/api/admin/archive-sku', (req, res) => {
    const { sku_code, reason } = req.body;
    
    if (!sku_code) {
        return res.status(400).json({ error: 'SKU code required' });
    }
    
    db.run(`INSERT INTO archived_skus (sku_code, reason)
            SELECT ?, ?
            WHERE NOT EXISTS (SELECT 1 FROM archived_skus WHERE sku_code = ?)`,
        [sku_code.toUpperCase(), reason || 'Manual archive', sku_code.toUpperCase()],
        function(err) {
            if (err) {
                console.error('Error archiving SKU:', err);
                return res.status(500).json({ error: err.message });
            }
            
            // Also deactivate in main table
            db.run('UPDATE skus SET active = 0 WHERE sku_code = ?', [sku_code.toUpperCase()]);
            
            console.log('üóÑÔ∏è Archived SKU:', sku_code);
            
            res.json({ 
                success: true,
                sku_code: sku_code,
                archived: this.changes > 0
            });
        }
    );
});

// ============================================
// SIMPLIFIED ARCHIVE MANAGEMENT
// ============================================

// Get all archived SKUs
app.get('/api/admin/archived-skus', (req, res) => {
    db.all(`SELECT sku_code, product_name, 
            COUNT(DISTINCT location) as location_count,
            SUM(quantity) as total_quantity
            FROM skus 
            WHERE archived = 1
            GROUP BY sku_code
            ORDER BY sku_code`,
        (err, skus) => {
            if (err) {
                console.error('Error fetching archived SKUs:', err);
                return res.status(500).json({ error: err.message });
            }
            
            res.json(skus || []);
        }
    );
});

// Archive a SKU (already exists in your code - keep it!)
// app.post('/api/sku/archive', ...) is already there

// Unarchive a SKU
app.post('/api/admin/unarchive-sku', (req, res) => {
    const { sku_code } = req.body;
    
    if (!sku_code) {
        return res.status(400).json({ error: 'SKU code required' });
    }
    
    db.run('UPDATE skus SET archived = 0, active = 1 WHERE sku_code = ?',
        [sku_code.toUpperCase()],
        function(err) {
            if (err) {
                console.error('Error unarchiving SKU:', err);
                return res.status(500).json({ error: err.message });
            }
            
            console.log('üìÇ Unarchived SKU:', sku_code);
            
            res.json({ 
                success: true,
                sku_code: sku_code,
                unarchived: this.changes > 0
            });
        }
    );
});

// Delete archived SKU permanently
app.post('/api/admin/delete-archived-sku', (req, res) => {
    const { sku_code } = req.body;
    
    if (!sku_code) {
        return res.status(400).json({ error: 'SKU code required' });
    }
    
    // Safety check: Only delete if archived
    db.get('SELECT archived FROM skus WHERE sku_code = ? LIMIT 1', [sku_code.toUpperCase()], (err, row) => {
        if (err) {
            return res.status(500).json({ error: err.message });
        }
        
        if (!row || row.archived !== 1) {
            return res.status(400).json({ 
                error: 'Can only delete archived SKUs. Please archive it first.' 
            });
        }
        
        // Safe to delete
        db.run('DELETE FROM skus WHERE sku_code = ?', [sku_code.toUpperCase()], function(err) {
            if (err) {
                console.error('Error deleting SKU:', err);
                return res.status(500).json({ error: err.message });
            }
            
            console.log('üóëÔ∏è Permanently deleted archived SKU:', sku_code, '- Removed', this.changes, 'records');
            
            res.json({ 
                success: true,
                sku_code: sku_code,
                records_deleted: this.changes
            });
        });
    });
});

function calculateOptimalBays(shelfAisles, result, res) {
    // Find the most common aisle (mode) or central aisle
    const aisleCounts = {};
    shelfAisles.forEach(aisle => {
        aisleCounts[aisle] = (aisleCounts[aisle] || 0) + 1;
    });
    
    // Get most common aisle
    let centralAisle = 'AA'; // default
    let maxCount = 0;
    Object.keys(aisleCounts).forEach(aisle => {
        if (aisleCounts[aisle] > maxCount) {
            maxCount = aisleCounts[aisle];
            centralAisle = aisle;
        }
    });
    
    // If multiple aisles equally common, pick the middle one
    const uniqueAisles = Object.keys(aisleCounts).sort();
    if (uniqueAisles.length > 1 && maxCount === 1) {
        const middleIndex = Math.floor(uniqueAisles.length / 2);
        centralAisle = uniqueAisles[middleIndex];
    }
    
    console.log('Shelf aisles:', shelfAisles);
    console.log('Optimal central aisle:', centralAisle);
    
    // Find empty bays near central aisle, preferring lower levels
    db.all(`
        SELECT pb.location, pb.aisle, pb.level, pb.bay_number
        FROM pallet_bays pb
        WHERE pb.status = 'available'
        AND NOT EXISTS (SELECT 1 FROM skus WHERE location = pb.location)
        ORDER BY 
            CASE WHEN pb.aisle = ? THEN 0 ELSE 1 END,
            ABS(CAST(SUBSTR(pb.aisle, 2, 2) AS INTEGER) - CAST(SUBSTR(?, 2, 2) AS INTEGER)),
            pb.level ASC,
            pb.bay_number ASC
        LIMIT ?`, 
        [centralAisle, centralAisle, result.palletItems.length + 5], 
        (err, emptyBays) => {
        
        if (err || !emptyBays || emptyBays.length === 0) {
            console.error('Error finding empty bays:', err);
            // Fallback to any empty bay
            db.all(`SELECT location, aisle, level FROM pallet_bays 
                    WHERE status='available' 
                    AND NOT EXISTS (SELECT 1 FROM skus WHERE location = location)
                    ORDER BY level ASC LIMIT ?`, 
                    [result.palletItems.length], (err2, fallbackBays) => {
                result.palletItems.forEach((item, idx) => {
                    item.suggested_bay = fallbackBays[idx] ? fallbackBays[idx].location : 'AA-01-2';
                    item.reason = 'Available bay';
                });
                res.json(result);
            });
            return;
        }
        
        // Assign bays to pallet items
        result.palletItems.forEach((item, idx) => {
            const bay = emptyBays[idx];
            if (bay) {
                item.suggested_bay = bay.location;
                
                // Build reason
                let reason = '';
                if (bay.aisle === centralAisle) {
                    reason = '‚úì Central to shelf locations (' + centralAisle + ')';
                } else {
                    reason = '‚úì Near shelf locations';
                }
                if (bay.level === 2) {
                    reason += ' ‚Ä¢ Ground level';
                }
                item.reason = reason;
            } else {
                item.suggested_bay = 'AA-01-2';
                item.reason = 'Available bay';
            }
        });
        
        res.json(result);
    });
}
// Admin: Delete pallet bay(s)
app.post('/api/admin/delete-bay', (req, res) => {
    const { bay_location } = req.body;
    
    console.log('Deleting bay:', bay_location);
    
    // Check if specific bay or all levels
    const isSpecific = bay_location.includes('-') && bay_location.split('-').length === 3;
    
    if (isSpecific) {
        // Delete specific bay (e.g., AA-05-4)
        db.run('DELETE FROM pallet_bays WHERE location = ?', [bay_location], function(err) {
            if (err) {
                console.error('Error deleting bay:', err);
                return res.status(500).json({ error: err.message });
            }
            
            if (this.changes === 0) {
                return res.json({ success: false, error: 'Bay not found' });
            }
            
            console.log('Deleted', this.changes, 'bay');
            res.json({ success: true, deleted: this.changes });
        });
    } else {
        // Delete all levels (e.g., AA-05 deletes AA-05-2, AA-05-3, AA-05-4, AA-05-5)
        db.run('DELETE FROM pallet_bays WHERE location LIKE ?', [bay_location + '%'], function(err) {
            if (err) {
                console.error('Error deleting bays:', err);
                return res.status(500).json({ error: err.message });
            }
            
            if (this.changes === 0) {
                return res.json({ success: false, error: 'No bays found matching ' + bay_location });
            }
            
            console.log('Deleted', this.changes, 'bays');
            res.json({ success: true, deleted: this.changes });
        });
    }
});
// Cycle Count APIs
app.get('/api/cycle-count/sku/:sku', (req, res) => {
    const { sku } = req.params;
    
    db.all(`SELECT location, location_type, quantity, product_name 
            FROM skus 
            WHERE sku_code = ? 
            ORDER BY location_type, location`, [sku], (err, rows) => {
        if (err) return res.status(500).json({ error: err.message });
        
        const productName = rows.length > 0 ? rows[0].product_name : sku;
        
        res.json({
            sku: sku,
            product_name: productName,
            locations: rows
        });
    });
});

app.get('/api/cycle-count/aisle/:aisle', (req, res) => {
    const { aisle } = req.params;
    
    db.all(`SELECT sku_code, product_name, location, location_type, quantity 
            FROM skus 
            WHERE location_type = 'pallet' 
            AND location LIKE ? 
            ORDER BY location, sku_code`, [aisle + '%'], (err, rows) => {
        if (err) return res.status(500).json({ error: err.message });
        
        res.json({
            aisle: aisle,
            items: rows
        });
    });
});

app.post('/api/cycle-count/confirm', (req, res) => {
    const { sku_code, location, system_qty, physical_qty, variance } = req.body;
    
    console.log('Cycle count confirmed:', sku_code, location, 'Variance:', variance);
    
    // Log the count
    db.run(`INSERT INTO movement_history (from_location, to_location, sku_code, reason) 
            VALUES (?, ?, ?, ?)`,
        [location, location, sku_code, 'Cycle count: '+physical_qty+' (was '+system_qty+')'],
        function(err) {
            if (err) console.error('Error logging count:', err);
        }
    );
    
    // Update quantity in skus table
    db.run(`UPDATE skus SET quantity = ? WHERE sku_code = ? AND location = ?`,
        [physical_qty, sku_code, location],
        function(err) {
            if (err) {
                console.error('Error updating quantity:', err);
                return res.status(500).json({ error: err.message });
            }
            
            res.json({ success: true, updated: this.changes });
        }
    );
});


app.get('/api/analytics/aisle-activity', (req, res) => {
    db.all(`SELECT 
            SUBSTR(from_location, 1, 2) as aisle,
            COUNT(*) as movements
            FROM movement_history
            WHERE moved_at >= datetime('now', '-30 days')
            AND from_location LIKE '__-__-_'
            GROUP BY aisle
            ORDER BY movements DESC`, (err, rows) => {
        if (err) return res.status(500).json({ error: err.message });
        res.json(rows);
    });
});

app.get('/api/analytics/slow-movers', (req, res) => {
    db.all(`SELECT 
            s.sku_code,
            s.product_name,
            s.location,
            s.location_type,
            MAX(mh.moved_at) as last_moved,
            CAST((julianday('now') - julianday(MAX(mh.moved_at))) AS INTEGER) as days_idle
            FROM skus s
            LEFT JOIN movement_history mh ON s.sku_code = mh.sku_code
            GROUP BY s.sku_code, s.location
            HAVING last_moved IS NULL OR days_idle >= 90
            ORDER BY days_idle DESC NULLS FIRST
            LIMIT 50`, (err, rows) => {
        if (err) return res.status(500).json({ error: err.message });
        
        // Set days_idle to 999 for never moved items
        rows.forEach(row => {
            if (!row.last_moved) row.days_idle = 999;
        });
        
        res.json(rows);
    });
});
// ==========================================
// ANALYTICS DASHBOARD MISSING ENDPOINTS
// ==========================================

// Analytics stats (used by Analytics dashboard)
app.get('/api/analytics/stats', (req, res) => {
  const stats = {};
  
  // Get warehouse utilization
  db.get('SELECT COUNT(*) as total_bays FROM pallet_bays', (err, row) => {
    if (err) {
      return res.status(500).json({ error: err.message });
    }
    
    const totalBays = row.total_bays;
    
    // Get occupied bays
    db.get(`SELECT COUNT(DISTINCT pb.location) as occupied_bays 
            FROM pallet_bays pb
            INNER JOIN skus s ON s.location = pb.location AND s.location_type = 'pallet'`,
      (err, occupiedRow) => {
        if (err) {
          return res.status(500).json({ error: err.message });
        }
        
        const occupiedBays = occupiedRow ? occupiedRow.occupied_bays : 0;
        
        // Calculate utilization (CAPPED AT 100%)
        stats.utilizationRate = totalBays > 0 
          ? Math.min(100, Math.round((occupiedBays / totalBays) * 100))
          : 0;
        
        // Get total movements in last 30 days
        db.get(`SELECT COUNT(*) as movements 
                FROM movement_history 
                WHERE moved_at >= datetime('now', '-30 days')`,
          (err, movRow) => {
            if (err) {
              console.error('Movements error:', err);
              stats.totalMovements = 0;
            } else {
              stats.totalMovements = movRow ? movRow.movements : 0;
            }
            
            // Get unique active SKUs
            db.get(`SELECT COUNT(DISTINCT sku_code) as unique_skus 
                    FROM skus 
                    WHERE (archived IS NULL OR archived = 0)`,
              (err, skuRow) => {
                if (err) {
                  console.error('SKUs error:', err);
                  stats.uniqueSKUs = 0;
                } else {
                  stats.uniqueSKUs = skuRow ? skuRow.unique_skus : 0;
                }
                
                // Get slow movers (pallets not moved in 30+ days) - FIXED QUERY
                db.get(`SELECT COUNT(*) as slow_count FROM (
                          SELECT pb.location
                          FROM pallet_bays pb
                          LEFT JOIN movement_history mh ON (mh.from_location = pb.location OR mh.to_location = pb.location)
                          WHERE EXISTS (SELECT 1 FROM skus WHERE location = pb.location AND location_type = 'pallet')
                          GROUP BY pb.location
                          HAVING MAX(mh.moved_at) < datetime('now', '-30 days') OR MAX(mh.moved_at) IS NULL
                        )`,
                  (err, slowRow) => {
                    if (err) {
                      console.error('Slow movers count error:', err);
                      stats.slowMovers = 0;
                    } else {
                      stats.slowMovers = slowRow ? slowRow.slow_count : 0;
                    }
                    
                    console.log('üìä Analytics stats:', stats);
                    res.json(stats);
                  }
                );
              }
            );
          }
        );
      }
    );
  });
});


// Relocation suggestions (items in EE/FF that moved recently)
app.get('/api/analytics/relocation-suggestions', (req, res) => {
    db.all(`
        SELECT 
            s.sku_code,
            s.product_name,
            s.location AS current_location,
            COUNT(mh.id) AS recent_movements
        FROM skus s
        LEFT JOIN movement_history mh ON s.sku_code = mh.sku_code
        WHERE s.location_type = 'pallet'
          AND (s.location LIKE 'EE%' OR s.location LIKE 'FF%')
          AND mh.moved_at >= datetime('now', '-30 days')
        GROUP BY s.sku_code, s.location
        HAVING recent_movements >= 3
        ORDER BY recent_movements DESC
        LIMIT 10
    `, (err, rows) => {
        if (err) return res.status(500).json({ error: err.message });

        const suggestions = rows.map(r => ({
            sku_code: r.sku_code,
            product_name: r.product_name,
            current_location: r.current_location,
            suggested_location: 'AA or BB (front aisles)',
            reason: `High activity (${r.recent_movements} movements in 30 days)`
        }));

        res.json(suggestions);
    });
});
// Analytics APIs
app.get('/api/analytics/stats', (req, res) => {
    // Get utilization rate - fixed to properly count occupied bays
    db.get(`SELECT 
        COUNT(DISTINCT CASE WHEN s.location IS NOT NULL THEN pb.location END) as occupied,
        COUNT(*) as total
        FROM pallet_bays pb
        LEFT JOIN skus s ON pb.location = s.location AND s.location_type = 'pallet'`, 
        (err, capacity) => {
        
        if (err) {
            console.error('Capacity error:', err);
            return res.status(500).json({ error: err.message });
        }
        
        const occupiedBays = capacity.occupied || 0;
        const totalBays = capacity.total || 1;
        const utilizationRate = Math.round((occupiedBays / totalBays) * 100);
        
        console.log('Utilization:', occupiedBays, '/', totalBays, '=', utilizationRate + '%');
        
        // Get movements in last 30 days
        db.get(`SELECT COUNT(*) as count FROM movement_history WHERE moved_at >= datetime('now', '-30 days')`, (err, movements) => {
            
            // Get unique SKUs
            db.get(`SELECT COUNT(DISTINCT sku_code) as count FROM skus`, (err, skus) => {
                
                // Get slow movers - PALLET BAYS ONLY (no movement in 90 days)
                db.get(`SELECT COUNT(DISTINCT s.sku_code) as count 
                        FROM skus s 
                        WHERE s.location_type = 'pallet'
                        AND s.sku_code NOT IN (
                            SELECT DISTINCT sku_code FROM movement_history 
                            WHERE moved_at >= datetime('now', '-90 days')
                        )`, (err, slow) => {
                    
                    res.json({
                        utilizationRate: utilizationRate,
                        totalMovements: movements ? movements.count : 0,
                        uniqueSKUs: skus ? skus.count : 0,
                        slowMovers: slow ? slow.count : 0
                    });
                });
            });
        });
    });
});

app.get('/api/analytics/aisle-activity', (req, res) => {
    db.all(`SELECT 
            SUBSTR(from_location, 1, 2) as aisle,
            COUNT(*) as movements
            FROM movement_history
            WHERE moved_at >= datetime('now', '-30 days')
            AND from_location LIKE '__-__-_'
            GROUP BY aisle
            ORDER BY movements DESC`, (err, rows) => {
        if (err) return res.status(500).json({ error: err.message });
        res.json(rows);
    });
});

app.get('/api/analytics/slow-movers', (req, res) => {
    db.all(`SELECT 
            s.sku_code,
            s.product_name,
            s.location,
            s.location_type,
            MAX(mh.moved_at) as last_moved,
            CAST((julianday('now') - julianday(MAX(mh.moved_at))) AS INTEGER) as days_idle
            FROM skus s
            LEFT JOIN movement_history mh ON s.sku_code = mh.sku_code
            WHERE s.location_type = 'pallet'
            GROUP BY s.sku_code, s.location
            HAVING last_moved IS NULL OR days_idle >= 90
            ORDER BY days_idle DESC NULLS FIRST
            LIMIT 50`, (err, rows) => {
        if (err) {
            console.error('Slow movers error:', err);
            return res.status(500).json({ error: err.message });
        }
        
        console.log('Slow movers found:', rows.length);
        
        // Set days_idle to 999 for never moved items
        rows.forEach(row => {
            if (!row.last_moved) row.days_idle = 999;
        });
        
        res.json(rows);
    });
});

app.get('/api/analytics/relocation-suggestions', (req, res) => {
    // Find items in back aisles (EE, FF) that have moved recently
    db.all(`SELECT 
            s.sku_code,
            s.product_name,
            s.location as current_location,
            COUNT(mh.id) as recent_movements
            FROM skus s
            JOIN movement_history mh ON s.sku_code = mh.sku_code
            WHERE s.location_type = 'pallet'
            AND (s.location LIKE 'EE%' OR s.location LIKE 'FF%')
            AND mh.moved_at >= datetime('now', '-30 days')
            GROUP BY s.sku_code, s.location
            HAVING recent_movements >= 3
            ORDER BY recent_movements DESC
            LIMIT 10`, (err, rows) => {
        if (err) return res.status(500).json({ error: err.message });
        
        // Suggest moving to front aisles
        const suggestions = rows.map(row => ({
            sku_code: row.sku_code,
            product_name: row.product_name,
            current_location: row.current_location,
            suggested_location: 'AA or BB (front aisles)',
            reason: 'High activity ('+row.recent_movements+' movements in 30 days) but located in back aisle'
        }));
        
        res.json(suggestions);
    });
});
// Daily capacity snapshot (run automatically or manually)
app.post('/api/analytics/snapshot-capacity', (req, res) => {
    db.get(`SELECT COUNT(DISTINCT location) as occupied
            FROM skus 
            WHERE location_type = 'pallet'`, (err, data) => {
        
        if (err) return res.status(500).json({ error: err.message });
        
        db.get(`SELECT COUNT(*) as total FROM pallet_bays`, (err, totalData) => {
            const utilization = Math.round((data.occupied / totalData.total) * 100);
            
            // Create table if doesn't exist
            db.run(`CREATE TABLE IF NOT EXISTS capacity_snapshots (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                snapshot_date DATE NOT NULL UNIQUE,
                occupied_bays INTEGER,
                total_bays INTEGER,
                utilization_rate INTEGER,
                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
            )`, (err) => {
                
                // Insert or replace today's snapshot
                db.run(`INSERT OR REPLACE INTO capacity_snapshots (snapshot_date, occupied_bays, total_bays, utilization_rate)
                        VALUES (DATE('now'), ?, ?, ?)`,
                    [data.occupied, totalData.total, utilization],
                    function(err) {
                        if (err) return res.status(500).json({ error: err.message });
                        
                        console.log('Daily capacity snapshot saved:', utilization + '%', 'on', new Date().toISOString().split('T')[0]);
                        res.json({ success: true, utilization: utilization, date: new Date().toISOString().split('T')[0] });
                    }
                );
            });
        });
    });
});

// Capacity trend - last 10 days (REDUCED FROM 30)
app.get('/api/analytics/capacity-trend', (req, res) => {
  // Generate daily snapshots for last 10 days
  db.all(`
    WITH RECURSIVE dates(date) AS (
      SELECT date('now', '-9 days')
      UNION ALL
      SELECT date(date, '+1 day')
      FROM dates
      WHERE date < date('now')
    )
    SELECT 
      dates.date as week_start,
      COALESCE(
        (SELECT COUNT(DISTINCT pb.location) * 100.0 / (SELECT COUNT(*) FROM pallet_bays)
         FROM pallet_bays pb
         INNER JOIN skus s ON s.location = pb.location AND s.location_type = 'pallet'
        ), 0
      ) as utilization_rate
    FROM dates
    ORDER BY dates.date
  `, (err, rows) => {
    if (err) {
      console.error('Capacity trend error:', err);
      return res.status(500).json({ error: err.message });
    }
    
    // Cap all values at 100%
    const cappedRows = rows.map(row => ({
      week_start: row.week_start,
      utilization_rate: Math.min(100, Math.round(row.utilization_rate))
    }));
    
    console.log('üìä Capacity trend:', cappedRows.length, 'days');
    res.json(cappedRows);
  });
});


// ============================================
// SKU MANAGEMENT ENDPOINTS
// ============================================

// Replace the existing /api/admin/rename-sku implementation with this safer version.
app.post('/api/admin/rename-sku', (req, res) => {
  const { old_sku, new_sku, new_product_name } = req.body;
  if (!old_sku || !new_sku) {
    return res.status(400).json({ success: false, error: 'Old and new SKU required' });
  }

  // Normalize
  const oldSKU = String(old_sku).trim().toUpperCase();
  const newSKU = String(new_sku).trim().toUpperCase();

  db.serialize(() => {
    db.run('BEGIN TRANSACTION');
    let palletChanges = 0, shelfChanges = 0, holdChanges = 0, bundleChanges = 0, movementChanges = 0;

    // 1) Update skus (pallets/shelves/holds are stored in single skus table)
    db.run(
      `UPDATE skus SET sku_code = ?, product_name = COALESCE(?, product_name) WHERE sku_code = ?`,
      [newSKU, new_product_name || null, oldSKU],
      function(err) {
        if (err) {
          db.run('ROLLBACK');
          console.error('Rename error (skus):', err);
          return res.status(500).json({ success: false, error: err.message });
        }
        // this.changes is number of rows changed for this statement
        const skusUpdated = this.changes || 0;

        // 2) Update bundle_components references
        db.run(
          `UPDATE bundle_components SET component_sku = ? WHERE component_sku = ?`,
          [newSKU, oldSKU],
          function(err) {
            if (err) {
              db.run('ROLLBACK');
              console.error('Rename error (bundle_components):', err);
              return res.status(500).json({ success: false, error: err.message });
            }
            bundleChanges = this.changes || 0;

            // 3) Update movement_history
            db.run(
              `UPDATE movement_history SET sku_code = ? WHERE sku_code = ?`,
              [newSKU, oldSKU],
              function(err) {
                if (err) {
                  db.run('ROLLBACK');
                  console.error('Rename error (movement_history):', err);
                  return res.status(500).json({ success: false, error: err.message });
                }
                movementChanges = this.changes || 0;

                // Commit and return summary
                db.run('COMMIT', (err) => {
                  if (err) {
                    db.run('ROLLBACK');
                    console.error('Commit error:', err);
                    return res.status(500).json({ success: false, error: err.message });
                  }

                  const totalChanges = skusUpdated + bundleChanges + movementChanges;
                  console.log(`‚úÖ Renamed ${oldSKU} ‚Üí ${newSKU}: skus=${skusUpdated}, bundles=${bundleChanges}, history=${movementChanges}`);

                  res.json({
                    success: true,
                    changes: totalChanges,
                    details: {
                      skus: skusUpdated,
                      bundles: bundleChanges,
                      movement_history: movementChanges
                    }
                  });
                });
              }
            );
          }
        );
      }
    );
  });
});

// ============================================
// ADD NEW SKU ENDPOINT
// ============================================
app.post('/api/admin/add-new-sku', (req, res) => {
    const { sku_code, product_name, location, location_type, quantity } = req.body;
    
    if(!sku_code || !location || !location_type){
        return res.status(400).json({ success: false, error: 'SKU code, location, and location type required' });
    }
    
    console.log('Adding new SKU:', sku_code, 'at', location);
    
    // Check if already exists at this location
    db.get('SELECT * FROM skus WHERE sku_code = ? AND location = ? AND location_type = ?',
        [sku_code, location, location_type], (err, existing) => {
        
        if(existing){
            return res.status(400).json({ 
                success: false, 
                error: 'SKU '+sku_code+' already exists at '+location 
            });
        }
        
        // Insert new SKU
        db.run('INSERT INTO skus (location, location_type, sku_code, product_name, quantity) VALUES (?, ?, ?, ?, ?)',
            [location, location_type, sku_code, product_name, quantity], function(err) {
            
            if(err){
                console.error('Insert error:', err);
                return res.status(500).json({ success: false, error: err.message });
            }
            
            console.log('‚úÖ New SKU added successfully');
            
            // Log the addition
            db.run('INSERT INTO movement_history (from_location, to_location, sku_code, reason) VALUES (?, ?, ?, ?)',
                ['NEW', location, sku_code, 'New SKU added to system']);
            
            res.json({ 
                success: true, 
                message: 'SKU '+sku_code+' added to '+location,
                id: this.lastID 
            });
        });
    });
});
// ============================================
// HOLD MANAGEMENT ENDPOINTS
// ============================================

// Return hold to original bay
app.post('/api/holds/:location/return', (req, res) => {
    const holdLocation = req.params.location;
    
    // Get hold info
    db.get('SELECT * FROM hold_locations WHERE location = ?', [holdLocation], (err, hold) => {
        if(err) {
            console.error('Get hold error:', err);
            return res.status(500).json({ error: err.message });
        }
        
        if(!hold) {
            return res.status(404).json({ error: 'Hold not found' });
        }
        
        const originalBay = hold.original_bay;
        
        // Get all stock in this hold
        db.all('SELECT * FROM skus WHERE location = ? AND location_type = ?', [holdLocation, 'hold'], (err, holdStock) => {
            if(err) {
                console.error('Get hold stock error:', err);
                return res.status(500).json({ error: err.message });
            }
            
            if(!holdStock || holdStock.length === 0) {
                return res.status(400).json({ error: 'No stock in hold to return' });
            }
            
            // Move each item back to original bay
            let moved = 0;
            holdStock.forEach(stock => {
                // Insert into pallet location
                db.run('INSERT INTO skus (location, location_type, sku_code, product_name, quantity) VALUES (?, ?, ?, ?, ?)',
                    [originalBay, 'pallet', stock.sku_code, stock.product_name, stock.quantity], (err) => {
                    
                    if(err) console.error('Insert error:', err);
                    
                    // Log movement
                    db.run('INSERT INTO movement_history (from_location, to_location, sku_code, moved_at, reason) VALUES (?, ?, ?, datetime(\'now\'), ?)',
                        [holdLocation, originalBay, stock.sku_code, 'Return from Hold']);
                    
                    moved++;
                    
                    // When all stock is moved
                    if(moved === holdStock.length) {
                        // Delete stock from hold
                        db.run('DELETE FROM skus WHERE location = ? AND location_type = ?', [holdLocation, 'hold'], (err) => {
                            
                            // Delete hold record
                            db.run('DELETE FROM hold_locations WHERE location = ?', [holdLocation], (err) => {
                                
                                // Update bay status to available
                                db.run('UPDATE pallet_bays SET status = ? WHERE location = ?', ['available', originalBay], (err) => {
                                    
                                    console.log('Hold returned successfully:', holdLocation, '‚Üí', originalBay);
                                    res.json({ success: true });
                                });
                            });
                        });
                    }
                });
            });
        });
    });
});

// Move hold to a new bay
app.post('/api/holds/:location/move', (req, res) => {
    const holdLocation = req.params.location;
    const { new_bay } = req.body;
    
    if(!new_bay) {
        return res.status(400).json({ error: 'New bay location required' });
    }
    
    // Get hold info
    db.get('SELECT * FROM hold_locations WHERE location = ?', [holdLocation], (err, hold) => {
        if(err || !hold) {
            return res.status(404).json({ error: 'Hold not found' });
        }
        
        // Check if destination bay exists
        db.get('SELECT * FROM pallet_bays WHERE location = ?', [new_bay], (err, destBay) => {
            if(!destBay) {
                return res.status(400).json({ error: `Bay ${new_bay} does not exist` });
            }
            
            // Check if destination already has stock
            db.get('SELECT COUNT(*) as count FROM skus WHERE location = ? AND location_type = ?', [new_bay, 'pallet'], (err, result) => {
                if(result && result.count > 0) {
                    return res.status(400).json({ error: `Bay ${new_bay} already contains stock. Choose an empty bay.` });
                }
                
                // Get all stock in hold
                db.all('SELECT * FROM skus WHERE location = ? AND location_type = ?', [holdLocation, 'hold'], (err, holdStock) => {
                    if(err) {
                        return res.status(500).json({ error: err.message });
                    }
                    
                    if(!holdStock || holdStock.length === 0) {
                        return res.status(400).json({ error: 'No stock in hold to move' });
                    }
                    
                    // Move stock to new bay
                    let moved = 0;
                    holdStock.forEach(stock => {
                        db.run('INSERT INTO skus (location, location_type, sku_code, product_name, quantity) VALUES (?, ?, ?, ?, ?)',
                            [new_bay, 'pallet', stock.sku_code, stock.product_name, stock.quantity], (err) => {
                            
                            // Log movement
                            db.run('INSERT INTO movement_history (from_location, to_location, sku_code, moved_at, reason) VALUES (?, ?, ?, datetime(\'now\'), ?)',
                                [holdLocation, new_bay, stock.sku_code, 'Hold moved to new bay']);
                            
                            moved++;
                            
                            // When all moved
                            if(moved === holdStock.length) {
                                // Delete from hold
                                db.run('DELETE FROM skus WHERE location = ? AND location_type = ?', [holdLocation, 'hold'], (err) => {
                                    
                                    // Delete hold record
                                    db.run('DELETE FROM hold_locations WHERE location = ?', [holdLocation], (err) => {
                                        
                                        // Clear old bay status
                                        if(hold.original_bay) {
                                            db.run('UPDATE pallet_bays SET status = ? WHERE location = ?', ['available', hold.original_bay]);
                                        }
                                        
                                        console.log('Hold moved successfully:', holdLocation, '‚Üí', new_bay);
                                        res.json({ success: true });
                                    });
                                });
                            }
                        });
                    });
                });
            });
        });
    });
});
app.post('/api/bays/:location/transfer', (req, res) => {
    const toLocation = req.params.location;
    const { to_location, fromLocation, from_location, skus, transfers } = req.body;
    
    // Support multiple naming formats
    const destinationBay = to_location || toLocation;
    const sourceBay = fromLocation || from_location;
    const itemsToTransfer = transfers || (skus ? skus.map(sku => ({ 
        sku_code: typeof sku === 'string' ? sku : sku.sku_code, 
        quantity: sku.quantity || null 
    })) : []);
    
    console.log('üì¶ Transfer request received:', {
        toLocation: destinationBay,
        fromLocation: sourceBay,
        items: itemsToTransfer.length,
        rawBody: req.body
    });
    
    // Validation
    if (!destinationBay) {
        console.error('‚ùå Missing destination bay');
        return res.status(400).json({ 
            success: false,
            error: 'Destination bay required'
        });
    }
    
    if (!sourceBay) {
        console.error('‚ùå Missing source bay');
        return res.status(400).json({ 
            success: false,
            error: 'Source bay required (fromLocation or from_location)'
        });
    }
    
    if (!itemsToTransfer || itemsToTransfer.length === 0) {
        console.error('‚ùå No items to transfer');
        return res.status(400).json({ 
            success: false,
            error: 'Items required (skus or transfers array)'
        });
    }
    
    // Check destination bay exists
    db.get('SELECT * FROM pallet_bays WHERE location = ?', [destinationBay], (err, destBay) => {
        if (err) {
            console.error('‚ùå Database error:', err);
            return res.status(500).json({ 
                success: false,
                error: err.message 
            });
        }
        
        if (!destBay) {
            console.error('‚ùå Destination bay not found:', destinationBay);
            return res.status(400).json({ 
                success: false,
                error: `Bay ${destinationBay} does not exist` 
            });
        }
        
        console.log('‚úÖ Starting transfer of', itemsToTransfer.length, 'items');
        
        // Transfer each SKU
        db.serialize(() => {
            db.run('BEGIN TRANSACTION');
            
            let completed = 0;
            let moved = 0;
            let errors = [];
            
            itemsToTransfer.forEach((item, index) => {
                const sku = item.sku_code || item;
                const transferQty = item.quantity;
                
                console.log(`  Processing item ${index + 1}:`, sku, 'qty:', transferQty);
                
                // Get stock details from source
                db.get('SELECT * FROM skus WHERE location = ? AND sku_code = ?', 
                    [sourceBay, sku], (err, sourceStock) => {
                    
                    if (err) {
                        console.error(`  ‚ùå Error fetching ${sku}:`, err.message);
                        errors.push(`${sku}: ${err.message}`);
                        completed++;
                        checkComplete();
                        return;
                    }
                    
                    if (!sourceStock) {
                        console.error(`  ‚ùå ${sku} not found in ${sourceBay}`);
                        errors.push(`${sku}: Not found in source bay`);
                        completed++;
                        checkComplete();
                        return;
                    }
                    
                    const qtyToMove = transferQty || sourceStock.quantity || 0;
                    const remainingQty = (sourceStock.quantity || 0) - qtyToMove;
                    
                    console.log(`  ‚Üí Moving ${qtyToMove} units (${remainingQty} will remain)`);
                    
                    // Check if destination already has this SKU
                    db.get('SELECT * FROM skus WHERE location = ? AND sku_code = ?',
                        [destinationBay, sku], (err, destStock) => {
                        
                        if (err) {
                            console.error(`  ‚ùå Error checking destination:`, err.message);
                            errors.push(`${sku}: ${err.message}`);
                            completed++;
                            checkComplete();
                            return;
                        }
                        
                        if (destStock) {
                            // SKU exists in destination - update quantity
                            const newQty = (destStock.quantity || 0) + qtyToMove;
                            console.log(`  ‚Üí Updating destination qty: ${destStock.quantity} + ${qtyToMove} = ${newQty}`);
                            
                            db.run('UPDATE skus SET quantity = ? WHERE location = ? AND sku_code = ?',
                                [newQty, destinationBay, sku], (err) => {
                                
                                if (err) {
                                    console.error(`  ‚ùå Update failed:`, err.message);
                                    errors.push(`${sku}: ${err.message}`);
                                    completed++;
                                    checkComplete();
                                } else {
                                    console.log(`  ‚úÖ Updated destination`);
                                    handleSourceUpdate();
                                }
                            });
                        } else {
                            // SKU doesn't exist in destination - insert new
                            console.log(`  ‚Üí Inserting new SKU in destination`);
                            
                            db.run('INSERT INTO skus (location, location_type, sku_code, product_name, quantity) VALUES (?, ?, ?, ?, ?)',
                                [destinationBay, 'pallet', sku, sourceStock.product_name, qtyToMove], (err) => {
                                
                                if (err) {
                                    console.error(`  ‚ùå Insert failed:`, err.message);
                                    errors.push(`${sku}: ${err.message}`);
                                    completed++;
                                    checkComplete();
                                } else {
                                    console.log(`  ‚úÖ Inserted into destination`);
                                    handleSourceUpdate();
                                }
                            });
                        }
                        
                        function handleSourceUpdate() {
                            if (remainingQty > 0) {
                                // Partial transfer - update quantity
                                console.log(`  ‚Üí Updating source qty to ${remainingQty}`);
                                
                                db.run('UPDATE skus SET quantity = ? WHERE location = ? AND sku_code = ?',
                                    [remainingQty, sourceBay, sku], (err) => {
                                    
                                    if (!err) {
                                        moved++;
                                        console.log(`  ‚úÖ Source updated`);
                                    } else {
                                        console.error(`  ‚ùå Source update failed:`, err.message);
                                    }
                                    
                                    // Log movement
                                    db.run('INSERT INTO movement_history (from_location, to_location, sku_code, reason) VALUES (?, ?, ?, ?)',
                                        [sourceBay, destinationBay, sku, `Merged: ${qtyToMove} units`]);
                                    
                                    completed++;
                                    checkComplete();
                                });
                            } else {
                                // Full transfer - delete from source
                                console.log(`  ‚Üí Deleting from source (full transfer)`);
                                
                                db.run('DELETE FROM skus WHERE location = ? AND sku_code = ?',
                                    [sourceBay, sku], (err) => {
                                    
                                    if (!err) {
                                        moved++;
                                        console.log(`  ‚úÖ Source deleted`);
                                    } else {
                                        console.error(`  ‚ùå Source delete failed:`, err.message);
                                    }
                                    
                                    // Log movement
                                    db.run('INSERT INTO movement_history (from_location, to_location, sku_code, reason) VALUES (?, ?, ?, ?)',
                                        [sourceBay, destinationBay, sku, `Merged: ${qtyToMove} units`]);
                                    
                                    completed++;
                                    checkComplete();
                                });
                            }
                        }
                    });
                });
            });
            
            function checkComplete() {
                if (completed === itemsToTransfer.length) {
                    db.run('COMMIT', (err) => {
                        if (err) {
                            console.error('‚ùå Commit error:', err);
                            db.run('ROLLBACK');
                            return res.status(500).json({ 
                                success: false, 
                                error: 'Transaction failed: ' + err.message 
                            });
                        }
                        
                        console.log('‚úÖ Transfer complete:', moved, 'items moved,', errors.length, 'errors');
                        
                        res.json({ 
                            success: true,
                            moved: moved,
                            errors: errors.length > 0 ? errors : undefined
                        });
                    });
                }
            }
        });
    });
});

// More comprehensive hold diagnostic
app.get('/api/admin/diagnose-holds-detailed', (req, res) => {
    const issues = {
        orphanedBays: [],
        emptyHolds: [],
        stockInWrongPlace: []
    };
    
    // Find bays marked on_hold
    db.all("SELECT * FROM pallet_bays WHERE status = 'on_hold'", (err, onHoldBays) => {
        if(err) return res.status(500).json({error: err.message});
        
        let bayChecks = 0;
        
        if(onHoldBays.length === 0){
            return checkEmptyHolds();
        }
        
        onHoldBays.forEach(bay => {
            // Check if hold_locations record exists
            db.get('SELECT * FROM hold_locations WHERE original_bay = ?', [bay.location], (err, hold) => {
                
                // Check if stock is still in the bay (WRONG!)
                db.get("SELECT COUNT(*) as count FROM skus WHERE location = ? AND location_type = 'pallet'", [bay.location], (err, palletStock) => {
                    
                    if(!hold){
                        // Bay is on_hold but no hold record
                        issues.orphanedBays.push({
                            bay: bay.location,
                            has_stock: palletStock.count > 0,
                            stock_count: palletStock.count
                        });
                    } else if(palletStock.count > 0){
                        // Hold exists but stock is in wrong place (still in pallet)
                        issues.stockInWrongPlace.push({
                            bay: bay.location,
                            hold_location: hold.location,
                            stock_count: palletStock.count
                        });
                    }
                    
                    bayChecks++;
                    if(bayChecks === onHoldBays.length){
                        checkEmptyHolds();
                    }
                });
            });
        });
// Repair orphaned bays
app.post('/api/admin/repair-orphaned-bays', (req, res) => {
    let fixed = 0;
    
    // Find all bays marked on_hold
    db.all("SELECT * FROM pallet_bays WHERE status = 'on_hold'", (err, bays) => {
        if(err) return res.status(500).json({error: err.message});
        
        if(bays.length === 0){
            return res.json({success: true, fixed: 0, message: 'No bays to fix'});
        }
        
        let checked = 0;
        
        bays.forEach(bay => {
            // Check if hold_locations record exists
            db.get('SELECT * FROM hold_locations WHERE original_bay = ?', [bay.location], (err, hold) => {
                
                if(!hold){
                    // No hold record - this bay is orphaned, clear the status
                    db.run("UPDATE pallet_bays SET status = 'available' WHERE location = ?", [bay.location], (err) => {
                        if(!err){
                            fixed++;
                            console.log('Cleared orphaned bay:', bay.location);
                        }
                    });
                }
                
                checked++;
                
                if(checked === bays.length){
                    // Also clean up any empty holds
                    db.all("SELECT * FROM hold_locations WHERE status = 'active'", (err, holds) => {
                        if(err || holds.length === 0){
                            return res.json({success: true, fixed: fixed, message: `Cleared ${fixed} orphaned bays`});
                        }
                        
                        let holdChecks = 0;
                        
                        holds.forEach(hold => {
                            db.get("SELECT COUNT(*) as count FROM skus WHERE location = ? AND location_type = 'hold'", [hold.location], (err, result) => {
                                if(result && result.count === 0){
                                    // Hold has no stock - delete it
                                    db.run('DELETE FROM hold_locations WHERE location = ?', [hold.location], (err) => {
                                        if(!err){
                                            fixed++;
                                            console.log('Deleted empty hold:', hold.location);
                                        }
                                    });
                                    
                                    // Also clear bay status
                                    if(hold.original_bay){
                                        db.run("UPDATE pallet_bays SET status = 'available' WHERE location = ?", [hold.original_bay]);
                                    }
                                }
                                
                                holdChecks++;
                                
                                if(holdChecks === holds.length){
                                    res.json({success: true, fixed: fixed, message: `Fixed ${fixed} issues`});
                                }
                            });
                        });
                    });
                }
            });
        });
    });
});
// Aliases for UI compatibility
app.get('/api/admin/find-stuck-holds', (req, res) => {
    req.url = '/api/admin/diagnose-holds';
    return app._router.handle(req, res);
});

app.post('/api/admin/fix-stuck-holds', (req, res) => {
    req.url = '/api/admin/repair-holds';
    return app._router.handle(req, res);
});
        
        function checkEmptyHolds(){
            // Check for holds with no stock
            db.all("SELECT * FROM hold_locations WHERE status = 'active'", (err, holds) => {
                if(err || holds.length === 0){
                    return res.json(issues);
                }
                
                let holdChecks = 0;
                
                holds.forEach(hold => {
                    db.get("SELECT COUNT(*) as count FROM skus WHERE location = ? AND location_type = 'hold'", [hold.location], (err, result) => {
                        if(result && result.count === 0){
                            issues.emptyHolds.push({
                                hold_location: hold.location,
                                original_bay: hold.original_bay
                            });
                        }
                        
                        holdChecks++;
                        if(holdChecks === holds.length){
                            res.json(issues);
                        }
                    });
                });
            });
        }
    });
});
// =============================
// DATABASE BACKUP MANAGEMENT
// =============================
const BACKUP_DIR = path.join(__dirname, 'backups');

// Ensure backup directory exists
if (!fs.existsSync(BACKUP_DIR)) {
    fs.mkdirSync(BACKUP_DIR, { recursive: true });
}

// Create a database backup
app.post('/api/admin/backup-database', (req, res) => {
    try {
        const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
        const backupFile = path.join(BACKUP_DIR, `warehouse-backup-${timestamp}.db`);
        fs.copyFileSync('./warehouse.db', backupFile);
        console.log(`Backup created: ${backupFile}`);
        res.json({ success: true, message: `Backup created: ${path.basename(backupFile)}` });
    } catch (err) {
        console.error('Backup failed:', err);
        res.status(500).json({ success: false, error: err.message });
    }
});

// List all existing backups
app.get('/api/admin/list-backups', (req, res) => {
  try {
    const files = fs.readdirSync(BACKUP_DIR)
      .filter(f => f.endsWith('.db'))
      .map(f => {
        const stats = fs.statSync(path.join(BACKUP_DIR, f));
        return {
          filename: f,
          size: `${(stats.size / 1024).toFixed(2)} KB`,
          created: stats.mtime
        };
      })
      .sort((a, b) => b.created - a.created);
    res.json({ backups: files }); // ‚úÖ frontend expects {backups: [...]}
  } catch (err) {
    res.status(500).json({ success: false, error: err.message });
  }
});


// Restore a specific backup
app.post('/api/admin/restore-backup', (req, res) => {
    const { filename } = req.body;
    try {
        const backupFile = path.join(BACKUP_DIR, filename);
        if (!fs.existsSync(backupFile)) {
            return res.status(404).json({ success: false, error: 'Backup not found' });
        }
        fs.copyFileSync(backupFile, './warehouse.db');
        res.json({ success: true, message: `Database restored from ${filename}` });
    } catch (err) {
        console.error('Restore failed:', err);
        res.status(500).json({ success: false, error: err.message });
    }
});

// ============================================
// MOVE FROM HOLD BAY TO NEW BAY
// ============================================
app.post('/api/holds/transfer', (req, res) => {
  const { fromHold, toBay } = req.body;

  if (!fromHold || !toBay) {
    return res.status(400).json({ success: false, error: 'Both hold and destination bays required' });
  }

  // Move all SKUs from the hold bay to the new bay
  db.serialize(() => {
    db.run(
      `UPDATE skus SET location = ? WHERE location = ?`,
      [toBay, fromHold],
      function(err) {
        if (err) return res.status(500).json({ success: false, error: err.message });

        // Update the old bay to 'available' and the new bay to 'occupied'
        db.run(`UPDATE pallet_bays SET status = 'available' WHERE location = ?`, [fromHold]);
        db.run(`UPDATE pallet_bays SET status = 'occupied' WHERE location = ?`, [toBay]);

        res.json({ success: true, moved: this.changes });
      }
    );
  });
});

// ============================================
// AUTOCOMPLETE FILTERED BY STATUS
// ============================================
app.get('/api/suggest/hold-locations', (req, res) => {
  const term = req.query.q || '';
  db.all(
    "SELECT location FROM pallet_bays WHERE status = 'hold' AND location LIKE ? ORDER BY location LIMIT 10",
    [`%${term}%`],
    (err, rows) => {
      if (err) return res.status(500).json({ error: err.message });
      res.json(rows.map(r => r.location));
    }
  );
});
// Smart search suggestions endpoint
app.get('/api/search/suggestions', (req, res) => {
    const query = req.query.q;
    
    if(!query || query.length < 2) {
        return res.json([]);
    }
    
    const searchPattern = '%' + query.toUpperCase() + '%';
    
    // Search across SKUs, bays, and products
    db.all(`
        SELECT 
            sku_code,
            product_name,
            location,
            location_type,
            quantity,
            'sku_' || location_type as type
        FROM skus
        WHERE 
            sku_code LIKE ? OR 
            product_name LIKE ? OR 
            location LIKE ?
        
        UNION ALL
        
        SELECT 
            NULL as sku_code,
            'Bay ' || location as product_name,
            location,
            'bay' as location_type,
            NULL as quantity,
            'bay' as type
        FROM pallet_bays
        WHERE location LIKE ?
        
        UNION ALL
        
        SELECT 
            NULL as sku_code,
            'Hold at ' || location as product_name,
            location,
            'hold' as location_type,
            NULL as quantity,
            'hold' as type
        FROM holds
        WHERE is_active = 1 AND location LIKE ?
        
        ORDER BY 
            CASE 
                WHEN sku_code LIKE ? THEN 1
                WHEN product_name LIKE ? THEN 2
                ELSE 3
            END,
            sku_code, product_name
        LIMIT 20
    `, [
        searchPattern, searchPattern, searchPattern,
        searchPattern,
        searchPattern,
        query.toUpperCase() + '%', query.toUpperCase() + '%'
    ], (err, results) => {
        if(err) {
            return res.status(500).json({ error: err.message });
        }
        
        // Format results for frontend
        const suggestions = results.map(row => {
            let title, subtitle;
            
            if(row.type.startsWith('sku_')) {
                title = row.sku_code;
                subtitle = row.product_name + ' ‚Ä¢ ' + row.location;
                if(row.quantity) {
                    subtitle += ' ‚Ä¢ Qty: ' + row.quantity;
                }
            } else if(row.type === 'bay') {
                title = row.location;
                subtitle = 'Pallet Bay';
            } else if(row.type === 'hold') {
                title = row.location;
                subtitle = 'On Hold';
            }
            
            return {
                type: row.type,
                title: title,
                subtitle: subtitle,
                location: row.location,
                sku_code: row.sku_code,
                quantity: row.quantity
            };
        });
        
        res.json(suggestions);
    });
});
// Adjust SKU quantity
app.post('/api/sku/adjust-quantity', (req, res) => {
    const { sku_code, location, location_type, new_quantity, reason } = req.body;
    
    if(new_quantity === 0) {
        // Delete if quantity is 0
        db.run(
            `DELETE FROM skus WHERE sku_code = ? AND location = ? AND location_type = ?`,
            [sku_code, location, location_type],
            function(err) {
                if(err) return res.status(500).json({ success: false, error: err.message });
                
                // Update bay status if empty
                if(location_type === 'pallet') {
                    db.get(
                        `SELECT COUNT(*) as count FROM skus WHERE location = ? AND location_type = 'pallet'`,
                        [location],
                        (err, row) => {
                            if(row && row.count === 0) {
                                db.run(`UPDATE pallet_bays SET status = 'empty' WHERE location = ?`, [location]);
                            }
                        }
                    );
                }
                
                res.json({ success: true, message: 'SKU removed (quantity 0)' });
            }
        );
    } else {
        // Update quantity
        db.run(
            `UPDATE skus SET quantity = ?, updated_at = datetime('now') 
             WHERE sku_code = ? AND location = ? AND location_type = ?`,
            [new_quantity, sku_code, location, location_type],
            function(err) {
                if(err) return res.status(500).json({ success: false, error: err.message });
                
                if(this.changes === 0) {
                    return res.status(404).json({ success: false, error: 'SKU not found at this location' });
                }
                
                res.json({ success: true, message: 'Quantity updated' });
            }
        );
    }
});

app.get('/api/suggest/available-locations', (req, res) => {
  const term = req.query.q || '';
  db.all(
    "SELECT location FROM pallet_bays WHERE status = 'available' AND location LIKE ? ORDER BY location LIMIT 10",
    [`%${term}%`],
    (err, rows) => {
      if (err) return res.status(500).json({ error: err.message });
      res.json(rows.map(r => r.location));
    }
  );
});


app.use(express.static('public'));

app.listen(PORT, '0.0.0.0', () => {
  console.log(`‚úÖ Backup routes registered`);
  console.log(`Server running on http://192.168.1.215:${PORT}`);
});
